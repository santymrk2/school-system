// src/hooks/useTeacherSecciones.ts
"use client";

import { useEffect, useState } from "react";
import { api } from "@/services/api";
import { useAuth } from "@/hooks/useAuth";
import type {
  SeccionDTO,
  AsignacionDocenteSeccionDTO,
  EmpleadoDTO,
} from "@/types/api-generated";

export function useTeacherSecciones() {
  const { user } = useAuth();
  const personaId = user?.personaId ?? null;

  const [loading, setLoading] = useState(true);
  const [secciones, setSecciones] = useState<SeccionDTO[]>([]);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    let mounted = true;
    (async () => {
      if (!personaId) {
        setLoading(false);
        setSecciones([]);
        return;
      }
      try {
        setLoading(true);

        // 0) Resolver empleadoId a partir de personaId
        const empleadosRes = await api.empleados
          .list()
          .catch(() => ({ data: [] as EmpleadoDTO[] }));
        const empleado = (empleadosRes.data ?? []).find(
          (e) => e.personaId === personaId,
        );
        const empleadoId = empleado?.id;
        if (!empleadoId) {
          if (mounted) {
            setSecciones([]);
            setError(null);
            setLoading(false);
          }
          return;
        }

        // 1) Traer asignaciones y filtrar por empleadoId
        const asigResp = await api.asignacionDocenteSeccion.list();
        const asignaciones = (asigResp.data ??
          []) as AsignacionDocenteSeccionDTO[];

        const seccionIds = Array.from(
          new Set(
            asignaciones
              // compat: empleadoId || personalId || docenteId
              .filter(
                (a: any) =>
                  (a.empleadoId ?? a.personalId ?? a.docenteId) === empleadoId,
              )
              .map((a: any) => a.seccionId ?? a.seccion?.id)
              .filter(Boolean),
          ),
        ) as number[];

        if (seccionIds.length === 0) {
          if (mounted) {
            setSecciones([]);
            setLoading(false);
          }
          return;
        }

        // 2) Traer secciones y filtrar
        const secResp = await api.secciones.list();
        const todas = secResp.data ?? [];
        const mias = todas.filter((s) => seccionIds.includes(s.id));

        if (mounted) {
          setSecciones(mias);
          setError(null);
        }
      } catch (e: any) {
        if (mounted) setError(e?.message ?? "Error cargando secciones");
      } finally {
        if (mounted) setLoading(false);
      }
    })();
    return () => {
      mounted = false;
    };
  }, [personaId]);

  return { loading, error, secciones };
}
// src/hooks/academico/useAlumnosActivosSeccion.ts
"use client";

import { useEffect, useState } from "react";
import { api } from "@/services/api";
import type { AlumnoLiteDTO } from "@/types/api-generated";

export function useAlumnosActivosSeccion(seccionId?: number) {
  const [alumnos, setAlumnos] = useState<AlumnoLiteDTO[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<unknown>(null);

  useEffect(() => {
    let alive = true;
    (async () => {
      try {
        setLoading(true);
        setError(null);
        if (!seccionId) {
          setAlumnos([]);
          return;
        }
        // ‚ùå sin fecha; el servicio maneja fallback
        const res = await api.seccionesAlumnos.bySeccionId(seccionId);
        if (!alive) return;
        setAlumnos(res.data ?? []);
      } catch (e) {
        if (!alive) return;
        setAlumnos([]);
        setError(e);
      } finally {
        if (alive) setLoading(false);
      }
    })();
    return () => {
      alive = false;
    };
  }, [seccionId]);

  return { alumnos, loading, error };
}
// src/hooks/academico/useCatalogosCierre.ts
"use client";

import { useEffect, useMemo, useState } from "react";
import { api } from "@/services/api/index";

export function useCatalogosCierre(seccionId?: number) {
  const [loading, setLoading] = useState(true);
  const [trimestres, setTrimestres] = useState<any[]>([]);
  const [seccionMaterias, setSeccionMaterias] = useState<any[]>([]);
  const [materias, setMaterias] = useState<any[]>([]);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    let alive = true;
    (async () => {
      try {
        setLoading(true);
        setError(null);
        const [tri, sms] = await Promise.all([
          api.trimestres.list().then((r) => r.data ?? []),
          api.seccionMaterias.list().then((r) => r.data ?? []),
        ]);
        if (!alive) return;
        setTrimestres(tri);
        setSeccionMaterias(sms);

        // Si no ten√©s endpoint de materias, omit√≠ esto o resolv√© nombre desde el DTO de SeccionMateria
        // setMaterias(await api.materias.list()...);
      } catch (e: any) {
        if (alive) setError(e?.message ?? "No se pudo cargar cat√°logos");
      } finally {
        if (alive) setLoading(false);
      }
    })();
    return () => {
      alive = false;
    };
  }, []);

  const seccionMateriaIds = useMemo(
    () =>
      new Set(
        seccionMaterias
          .filter((sm: any) => (sm.seccionId ?? sm.seccion?.id) === seccionId)
          .map((sm: any) => sm.id),
      ),
    [seccionMaterias, seccionId],
  );

  // Si tu DTO de SeccionMateria ya trae materia.nombre, √∫salo directo en la vista
  return {
    loading,
    error,
    trimestres,
    seccionMaterias,
    materias,
    seccionMateriaIds,
  };
}
// src/hooks/academico/useSeccionAlumnos.ts
"use client";

import { useEffect, useState } from "react";
import { api } from "@/services/api/index";

export function useSeccionAlumnos(seccionId?: number, fecha?: string) {
  const [loading, setLoading] = useState(false);
  const [alumnos, setAlumnos] = useState<any[]>([]);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!seccionId) return;
    let alive = true;
    (async () => {
      try {
        setLoading(true);
        setError(null);
        const { data } = await api.secciones.alumnos(seccionId, fecha);
        if (!alive) return;
        setAlumnos(data ?? []);
      } catch (e: any) {
        if (alive) setError(e?.message ?? "No se pudo cargar alumnos");
      } finally {
        if (alive) setLoading(false);
      }
    })();
    return () => {
      alive = false;
    };
  }, [seccionId, fecha]);

  return { loading, alumnos, error };
}
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }
// src/hooks/useSeccionAlumnosFull.ts
"use client";

import { useEffect, useState } from "react";
import { api } from "@/services/api";
import type {
  AlumnoLiteDTO,
  AlumnoDTO,
  PersonaDTO,
} from "@/types/api-generated";

export type StudentVM = {
  matriculaId: number;
  alumnoId: number;
  nombreCompleto: string;
  documento?: string | null;
  email?: string | null;
  telefono?: string | null;
};

export function useSeccionAlumnosFull(seccionId: number, fechaISO: string) {
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [items, setItems] = useState<StudentVM[]>([]);

  useEffect(() => {
    let alive = true;
    (async () => {
      setLoading(true);
      setError(null);
      try {
        const { data: lite } = await api.seccionesAlumnos.bySeccionId(
          seccionId,
          fechaISO,
        );

        const uniqueAlumnoIds = Array.from(
          new Set((lite ?? []).map((l) => l.alumnoId)),
        );
        const alumnos = await Promise.all(
          uniqueAlumnoIds.map((id) =>
            api.alumnos
              .getById(id)
              .then((r) => r.data as AlumnoDTO)
              .catch(() => null),
          ),
        );

        // persona por alumno
        const personaCache = new Map<number, PersonaDTO>();
        const personaByAlumnoId = new Map<number, PersonaDTO | null>();
        for (const a of alumnos) {
          if (!a) continue;
          const pid = (a as any).personaId as number | undefined;
          if (pid && !personaCache.has(pid)) {
            const p = await api.personasCore
              .getById(pid)
              .then((r) => r.data)
              .catch(() => null);
            if (p) personaCache.set(pid, p);
          }
          personaByAlumnoId.set(
            (a as any).id,
            pid ? (personaCache.get(pid) ?? null) : null,
          );
        }

        const vm: StudentVM[] = (lite ?? []).map((l: AlumnoLiteDTO) => {
          const p = personaByAlumnoId.get(l.alumnoId) ?? null;
          const documento = p?.dni ?? null;
          return {
            matriculaId: l.matriculaId,
            alumnoId: l.alumnoId,
            nombreCompleto: l.nombreCompleto,
            documento,
            email: p?.email ?? null,
            telefono: p?.telefono ?? null,
          };
        });

        if (alive) setItems(vm);
      } catch (e: any) {
        if (alive) setError(e?.message ?? "No se pudo cargar el roster.");
      } finally {
        if (alive) setLoading(false);
      }
    })();
    return () => {
      alive = false;
    };
  }, [seccionId, fechaISO]);

  const count = items.length;
  return { loading, error, items, count };
}
// src/hooks/useVisibleMenu.ts
"use client";
import { useMemo } from "react";
import { MENU, type MenuItem } from "@/lib/menu";
import type { UserRole } from "@/types/api-generated";

export function useVisibleMenu(role?: UserRole | null) {
  return useMemo<MenuItem[]>(() => {
    if (!role) return MENU.filter((i) => !i.roles);
    return MENU.filter((i) => !i.roles || i.roles.includes(role));
  }, [role]);
}
// src/hooks/useQuickStats.ts
"use client";
import { useEffect, useState } from "react";
import { api } from "@/services/api";
import { useActivePeriod } from "@/hooks/scope/useActivePeriod";

export type QuickStats = {
  alumnosActivos: number;
  docentesActivos: number;
  postulacionesPendientes: number;
  licenciasActivas: number;
  actasSinFirmar: number;
};

function inRangeISO(
  todayISO: string,
  from?: string | null,
  to?: string | null,
) {
  // Comparaci√≥n lexicogr√°fica segura para YYYY-MM-DD
  const t = todayISO;
  const okFrom = !from || t >= from;
  const okTo = !to || t <= to;
  return okFrom && okTo;
}

function getPeriodoIdSafe(s: any): number | undefined {
  // Acepta varias formas seg√∫n DTOs viejos/nuevos
  return (
    s?.periodoEscolarId ??
    s?.periodoId ??
    s?.periodoEscolar?.id ??
    s?.periodo?.id
  );
}

export function useQuickStats() {
  const { periodoEscolarId, hoyISO } = useActivePeriod();
  const [data, setData] = useState<QuickStats | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    let alive = true;
    if (!periodoEscolarId || !hoyISO) return;

    (async () => {
      try {
        setLoading(true);

        // ========= Alumnos activos (por secciones del per√≠odo, deduplicando) =========
        const seccionesRes = await api.secciones
          .list()
          .catch(() => ({ data: [] as any[] }));
        const seccionesAll = seccionesRes.data ?? [];
        const seccionesPeriodo = seccionesAll.filter(
          (s) => getPeriodoIdSafe(s) === periodoEscolarId,
        );

        // OJO: ac√° estaba el fallo: ¬°hay que usar seccionesAlumnos.bySeccionId!
        const alumnosLists = await Promise.all(
          seccionesPeriodo.map((s: any) =>
            api.seccionesAlumnos
              .bySeccionId(s.id, hoyISO) // <--- endpoint correcto de tu servicio
              .then((r) => r.data ?? [])
              .catch(() => []),
          ),
        );

        const alumnosSet = new Set<number>();
        for (const arr of alumnosLists) {
          for (const a of arr as any[]) {
            // Soporta AlumnoLiteDTO nuevo o alg√∫n DTO viejo
            const id = a.alumnoId ?? a.id;
            if (id != null) alumnosSet.add(id);
          }
        }

        // ========= Docentes activos hoy (asignaciones vigentes) =========
        const asigResp = await api.asignacionDocenteSeccion
          .list()
          .catch(() => ({ data: [] as any[] }));
        const asigs = asigResp.data ?? [];
        const docentes = new Set<number>();
        for (const a of asigs as any[]) {
          const vd = a.vigenciaDesde ?? a.desde;
          const vh = a.vigenciaHasta ?? a.hasta;
          if (inRangeISO(hoyISO, vd, vh)) {
            const eid = a.empleadoId ?? a.personalId ?? a.docenteId;
            if (eid != null) docentes.add(eid);
          }
        }

        // ========= Postulaciones pendientes (si el m√≥dulo existe) =========
        let postulPend = 0;
        if (api.solicitudesAdmision?.list) {
          const sol =
            (await api.solicitudesAdmision.list().catch(() => ({ data: [] })))
              .data ?? [];
          postulPend = sol.filter((s: any) =>
            String(s.estado ?? "")
              .toUpperCase()
              .includes("PEND"),
          ).length;
        }

        // ========= Licencias activas hoy =========
        const licRes = await api.licencias
          .list()
          .catch(() => ({ data: [] as any[] }));
        const lic = licRes.data ?? [];
        const licAct = lic.filter((l: any) => {
          const d = l.desde ?? l.fechaInicio ?? l.inicio;
          const h = l.hasta ?? l.fechaFin ?? l.fin;
          return inRangeISO(hoyISO, d, h);
        }).length;

        // ========= Actas de accidente sin firmar (BORRADOR) =========
        const actasRes = await api.actasAccidente
          .list()
          .catch(() => ({ data: [] as any[] }));
        const actas = actasRes.data ?? [];
        const sinFirmar = actas.filter(
          (a: any) => String(a.estado ?? "").toUpperCase() === "BORRADOR",
        ).length;

        if (!alive) return;
        setData({
          alumnosActivos: alumnosSet.size,
          docentesActivos: docentes.size,
          postulacionesPendientes: postulPend,
          licenciasActivas: licAct,
          actasSinFirmar: sinFirmar,
        });
      } finally {
        if (alive) setLoading(false);
      }
    })();

    return () => {
      alive = false;
    };
  }, [periodoEscolarId, hoyISO]);

  return { data, loading };
}
// src/hooks/admin/useMateriasAdminData.ts
"use client";

import { useCallback, useEffect, useState } from "react";
import { api } from "@/services/api";
import type { EmpleadoDTO, PersonaDTO } from "@/types/api-generated";

export type Materia = { id: number; nombre: string };
export type SeccionMateria = {
  id: number;
  seccionId: number;
  materiaId: number;
};
export type Personal = { id: number; nombre: string; apellido: string };
export type Asignacion = {
  id: number;
  seccionMateriaId: number;
  personalId: number; // mantenemos nombre local pero ahora es empleadoId
  rol: "TITULAR" | "SUPLENTE";
  vigenciaDesde: string;
  vigenciaHasta?: string | null;
};

export function useMateriasAdminData(canAdmin: boolean) {
  const [loading, setLoading] = useState<boolean>(true);
  const [materias, setMaterias] = useState<Materia[]>([]);
  const [seccionMaterias, setSeccionMaterias] = useState<SeccionMateria[]>([]);
  const [personales, setPersonales] = useState<Personal[]>([]);
  const [asignaciones, setAsignaciones] = useState<Asignacion[]>([]);
  const [error, setError] = useState<string | null>(null);

  const refresh = useCallback(async () => {
    if (!canAdmin) {
      setMaterias([]);
      setSeccionMaterias([]);
      setPersonales([]);
      setAsignaciones([]);
      setLoading(false);
      setError(null);
      return;
    }

    setLoading(true);
    setError(null);
    try {
      const [matRes, smRes, empRes] = await Promise.all([
        api.materias.list(),
        api.seccionMaterias.list(),
        api.empleados.list(),
      ]);

      setMaterias(matRes.data ?? []);
      setSeccionMaterias(smRes.data ?? []);

      const empleados = (empRes.data ?? []) as EmpleadoDTO[];
      // Resolver nombres via Persona
      const personasMap = new Map<number, PersonaDTO>();
      for (const e of empleados) {
        if (!e.personaId || personasMap.has(e.personaId)) continue;
        const p = await api.personasCore
          .getById(e.personaId)
          .then((r) => r.data)
          .catch(() => null);
        if (p) personasMap.set(e.personaId, p);
      }
      const pers: Personal[] = empleados.map((e) => {
        const p = e.personaId ? personasMap.get(e.personaId) : undefined;
        return {
          id: e.id,
          nombre: p?.nombre ?? "",
          apellido: p?.apellido ?? "",
        };
      });
      setPersonales(pers);

      // Asignaciones de materia
      const asignList = await api.asignacionDocenteMateria.list();
      // normalizamos campo personalId (empleadoId)
      setAsignaciones(
        (asignList.data ?? []).map((a: any) => ({
          ...a,
          personalId: a.empleadoId ?? a.personalId ?? a.docenteId,
        })),
      );
    } catch (e: any) {
      setError(e?.message ?? "No se pudo cargar materias/asignaciones.");
    } finally {
      setLoading(false);
    }
  }, [canAdmin]);

  useEffect(() => {
    void refresh();
  }, [refresh]);

  return {
    loading,
    error,
    materias,
    seccionMaterias,
    personales,
    asignaciones,
    refresh,
  };
}
// src/hooks/useScopedSecciones.ts
"use client";

import { useEffect, useState } from "react";
import { api } from "@/services/api";
import { useViewerScope } from "./useViewerScope";
import type {
  SeccionDTO,
  AsignacionDocenteSeccionDTO,
  EmpleadoDTO,
  PersonaDTO,
} from "@/types/api-generated";

function vigente(
  desde?: string | null,
  hasta?: string | null,
  hoyISO?: string,
) {
  const today = hoyISO ?? new Date().toISOString().slice(0, 10);
  return (!desde || today >= desde) && (!hasta || today <= hasta);
}

export function useScopedSecciones(opts?: {
  fecha?: string;
  periodoEscolarId?: number;
  includeTitular?: boolean;
}) {
  const { type, personaId } = useViewerScope();
  const fecha = opts?.fecha ?? new Date().toISOString().slice(0, 10);
  const periodoEscolarId = opts?.periodoEscolarId;
  const includeTitular = !!opts?.includeTitular;

  const [loading, setLoading] = useState(true);
  const [secciones, setSecciones] = useState<SeccionDTO[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [titularBySeccionId, setTitularBySeccionId] = useState<
    Map<number, string>
  >(new Map());

  useEffect(() => {
    let alive = true;
    (async () => {
      try {
        setLoading(true);
        setError(null);

        // STAFF ‚Üí todas las secciones (opcional: filtrar por per√≠odo)
        if (type === "staff") {
          const [secs, asig, empleados] = await Promise.all([
            api.secciones.list().then((r) => r.data ?? []),
            includeTitular
              ? api.asignacionDocenteSeccion.list().then((r) => r.data ?? [])
              : Promise.resolve([]),
            includeTitular
              ? api.empleados.list().then((r) => r.data ?? [])
              : Promise.resolve([]),
          ]);

          // Si pedimos titular, mapear empleadoId -> nombre completo (via Persona)
          if (includeTitular) {
            const personaCache = new Map<number, PersonaDTO>();
            const nombreEmpleado = async (emp: EmpleadoDTO) => {
              if (!emp.personaId) return "";
              if (!personaCache.has(emp.personaId)) {
                const p = await api.personasCore
                  .getById(emp.personaId)
                  .then((r) => r.data as PersonaDTO);
                personaCache.set(emp.personaId, p);
              }
              const p = personaCache.get(emp.personaId)!;
              return `${p.apellido ?? ""} ${p.nombre ?? ""}`.trim();
            };

            const map = new Map<number, string>();
            for (const a of asig as AsignacionDocenteSeccionDTO[]) {
              const rol = String((a as any).rol ?? "").toUpperCase();
              if (rol !== "MAESTRO_TITULAR") continue;
              if (
                !vigente(
                  (a as any).vigenciaDesde,
                  (a as any).vigenciaHasta,
                  fecha,
                )
              )
                continue;

              const sid = (a as any).seccionId ?? (a as any).seccion?.id;
              const eid =
                (a as any).empleadoId ??
                (a as any).personalId ??
                (a as any).docenteId;
              if (!sid || !eid) continue;

              const emp = (empleados as EmpleadoDTO[]).find(
                (e) => e.id === eid,
              );
              if (emp) map.set(sid, await nombreEmpleado(emp));
            }
            if (alive) setTitularBySeccionId(map);
          }

          let filtradas = secs;
          if (periodoEscolarId != null) {
            filtradas = filtradas.filter(
              (s: any) =>
                (s.periodoEscolarId ?? s.periodoId ?? s.periodoEscolar?.id) ===
                periodoEscolarId,
            );
          }

          if (alive) setSecciones(filtradas);
          return;
        }

        // TEACHER ‚Üí asignaciones del docente/empleado (vigentes en fecha)
        if (type === "teacher") {
          if (!personaId) {
            if (alive) setSecciones([]);
            return;
          }

          // 1) resolver empleadoId desde personaId
          const empleadosRes = await api.empleados
            .list()
            .catch(() => ({ data: [] as EmpleadoDTO[] }));
          const empleado = (empleadosRes.data ?? []).find(
            (e) => e.personaId === personaId,
          );
          const empleadoId = empleado?.id;
          if (!empleadoId) {
            if (alive) setSecciones([]);
            return;
          }

          // 2) traer asignaciones (endpoint by-empleado si existe)
          let asigs: AsignacionDocenteSeccionDTO[] = [];
          if ((api.asignacionDocenteSeccion as any).byEmpleadoVigentes) {
            const r = await (
              api.asignacionDocenteSeccion as any
            ).byEmpleadoVigentes(empleadoId, fecha);
            asigs = r.data ?? [];
          } else {
            const r = await api.asignacionDocenteSeccion.list();
            const todos = r.data ?? [];
            asigs = todos.filter(
              (a: any) =>
                (a.empleadoId ?? a.personalId ?? a.docenteId) === empleadoId &&
                vigente(
                  (a as any).vigenciaDesde,
                  (a as any).vigenciaHasta,
                  fecha,
                ),
            );
          }

          const ids = Array.from(
            new Set(
              asigs
                .map((a: any) => a.seccionId ?? a.seccion?.id)
                .filter(Boolean),
            ),
          ) as number[];

          if (ids.length === 0) {
            if (alive) setSecciones([]);
            return;
          }

          let secs = (await api.secciones.list()).data ?? [];
          secs = secs.filter((s) => ids.includes(s.id));

          if (periodoEscolarId != null) {
            secs = secs.filter(
              (s: any) =>
                (s.periodoEscolarId ?? s.periodoId ?? s.periodoEscolar?.id) ===
                periodoEscolarId,
            );
          }

          if (alive) setSecciones(secs);
          return;
        }

        // FAMILY / GUEST
        if (alive) setSecciones([]);
      } catch (e: any) {
        if (alive) setError(e?.message ?? "Error cargando secciones");
      } finally {
        if (alive) setLoading(false);
      }
    })();
    return () => {
      alive = false;
    };
  }, [type, personaId, fecha, periodoEscolarId, includeTitular]);

  return { loading, error, secciones, titularBySeccionId };
}
"use client";

import { useMemo } from "react";
import { useViewerScope } from "./useViewerScope";
import { useActivePeriod } from "./useActivePeriod";
import { useScopedSecciones } from "./useScopedSecciones";
import { useFamilyAlumnos } from "@/hooks/useFamilyAlumnos";

/**
 * Unifica la ‚Äúpantalla √≠ndice‚Äù:
 * - staff / teacher ‚Üí secciones visibles
 * - family ‚Üí hijos (alumnos)
 *
 * Lo pod√©s usar igual en m√≥dulos de ex√°menes, asistencias y accidentes.
 */
export function useScopedIndex(opts?: {
  includeTitularSec?: boolean; // √∫til para staff (mostrar titular)
}) {
  const { type } = useViewerScope();
  const {
    loading: loadingPeriodo,
    periodoEscolarId,
    hoyISO,
  } = useActivePeriod();

  // Secciones para staff/teacher
  const {
    loading: loadingSecs,
    error: errorSecs,
    secciones,
    titularBySeccionId,
  } = useScopedSecciones({
    fecha: hoyISO,
    periodoEscolarId: periodoEscolarId ?? undefined,
    includeTitular: !!opts?.includeTitularSec,
  });

  // Hijos para family
  const {
    alumnos,
    loading: loadingHijos,
    error: errorHijos,
  } = useFamilyAlumnos?.() ?? {
    alumnos: [],
    loading: false,
    error: null,
  };

  const loading =
    loadingPeriodo || (type === "family" ? loadingHijos : loadingSecs);
  const error = type === "family" ? errorHijos : errorSecs;

  return useMemo(() => {
    if (type === "family") {
      return {
        scope: "family" as const,
        loading,
        error,
        hijos: alumnos, // array de AlumnoLiteDTO
        secciones: [] as any[], // vac√≠o en family
        titularBySeccionId: new Map<number, string>(),
        periodoEscolarId,
        hoyISO,
      };
    }
    // staff / teacher
    return {
      scope: (type === "staff" ? "staff" : "teacher") as const,
      loading,
      error,
      hijos: [] as any[], // vac√≠o si no es family
      secciones, // array de SeccionDTO
      titularBySeccionId,
      periodoEscolarId,
      hoyISO,
    };
  }, [
    type,
    loading,
    error,
    alumnos,
    secciones,
    titularBySeccionId,
    periodoEscolarId,
    hoyISO,
  ]);
}
"use client";

import { useMemo } from "react";
import { useAuth } from "@/hooks/useAuth";

const ROLES_STAFF = new Set(["ADMIN", "DIRECTOR", "SECRETARY"]);

export function useViewerScope() {
  const { user } = useAuth();
  const roles = (user?.roles ?? []).map((r: any) => String(r).toUpperCase());

  return useMemo(() => {
    const isStaff = roles.some((r) => ROLES_STAFF.has(r));
    const isTeacher = roles.includes("TEACHER");
    const isFamily = roles.includes("FAMILY");

    // prioridad: si es staff, lo tratamos como staff (aunque tambi√©n sea teacher)
    const type: "staff" | "teacher" | "family" | "guest" = isStaff
      ? "staff"
      : isTeacher
        ? "teacher"
        : isFamily
          ? "family"
          : "guest";

    return {
      type,
      roles,
      // personaId = Personal.id para teacher, Familiar.id para family (seg√∫n tu backend)
      personaId: user?.personaId ?? null,
      user,
    };
  }, [roles, user]);
}
"use client";

import { useEffect, useMemo, useState } from "react";
import { api } from "@/services/api";
import type { PeriodoEscolarDTO, TrimestreDTO } from "@/types/api-generated";

type UseActivePeriodOpts = {
  today?: string; // YYYY-MM-DD
  preferOpen?: boolean; // prioriza per√≠odo con trimestres abiertos hoy
  tickMidnight?: boolean; // actualiza hoyISO al cruzar medianoche (default true)
};

function toLocalISODate(d = new Date()): string {
  const tz = d.getTimezoneOffset();
  return new Date(d.getTime() - tz * 60_000).toISOString().slice(0, 10);
}

const norm = {
  start: (t: TrimestreDTO) =>
    ((t as any).fechaInicio ?? (t as any).inicio ?? "1900-01-01") as string,
  end: (t: TrimestreDTO) =>
    ((t as any).fechaFin ?? (t as any).fin ?? "2999-12-31") as string,
  periodoId: (t: TrimestreDTO) =>
    ((t as any).periodoEscolarId ?? (t as any).periodoId) as number | undefined,
  closed: (t: TrimestreDTO) =>
    (t as any).cerrado ?? (t as any).isCerrado ?? false,
};

const inRange = (dateISO: string, fromISO: string, toISO: string) =>
  dateISO >= fromISO && dateISO <= toISO;

export function useActivePeriod(opts?: UseActivePeriodOpts) {
  const [periodos, setPeriodos] = useState<PeriodoEscolarDTO[]>([]);
  const [trimestres, setTrimestres] = useState<TrimestreDTO[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // hoyISO controlado por props (tests) o por reloj local
  const [today, setToday] = useState<string>(opts?.today ?? toLocalISODate());
  const preferOpen = opts?.preferOpen ?? true;
  const tickMidnight = opts?.tickMidnight ?? true;

  // Opcional: actualizar a medianoche si no viene por props
  useEffect(() => {
    if (opts?.today || !tickMidnight) return;
    const id = setInterval(() => {
      const now = toLocalISODate();
      setToday((prev) => (prev !== now ? now : prev));
    }, 60_000); // chequeo cada 1 min (barato y suficiente)
    return () => clearInterval(id);
  }, [opts?.today, tickMidnight]);

  // Si cambian props de test, sincronizamos
  useEffect(() => {
    if (opts?.today) setToday(opts.today);
  }, [opts?.today]);

  useEffect(() => {
    let alive = true;
    (async () => {
      try {
        setLoading(true);
        setError(null);
        const [per, tri] = await Promise.all([
          api.periodos.list().then((r) => r.data ?? []),
          api.trimestres.list().then((r) => r.data ?? []),
        ]);
        if (!alive) return;
        setPeriodos(per);
        setTrimestres(tri);
      } catch (e: any) {
        if (alive)
          setError(e?.message ?? "No se pudo cargar el calendario escolar");
      } finally {
        if (alive) setLoading(false);
      }
    })();
    return () => {
      alive = false;
    };
  }, []);

  const computed = useMemo(() => {
    if (!periodos.length || !trimestres.length) {
      return {
        periodo: undefined as PeriodoEscolarDTO | undefined,
        trimestresDelPeriodo: [] as TrimestreDTO[],
        allTriIds: [] as number[],
        activeTriIdsToday: [] as number[],
      };
    }

    const trisByPeriodo = new Map<number, TrimestreDTO[]>();
    for (const t of trimestres) {
      const pid = norm.periodoId(t);
      if (!pid) continue;
      const arr = trisByPeriodo.get(pid) ?? [];
      arr.push(t);
      trisByPeriodo.set(pid, arr);
    }

    let elegido: PeriodoEscolarDTO | undefined;
    if (preferOpen) {
      elegido = periodos.find((p) => {
        const ts = trisByPeriodo.get(p.id) ?? [];
        return ts.some(
          (t) => !norm.closed(t) && inRange(today, norm.start(t), norm.end(t)),
        );
      });
    }
    if (!elegido) {
      elegido = [...periodos].sort(
        (a: any, b: any) => (b.anio ?? 0) - (a.anio ?? 0),
      )[0];
    }

    const trimestresDelPeriodo = elegido
      ? (trisByPeriodo.get(elegido.id) ?? [])
      : [];
    // ordena por fecha de inicio por prolijidad
    trimestresDelPeriodo.sort((a, b) =>
      norm.start(a) < norm.start(b) ? -1 : 1,
    );

    const allTriIds = trimestresDelPeriodo.map((t) => t.id);
    const activeTriIdsToday = trimestresDelPeriodo
      .filter(
        (t) => !norm.closed(t) && inRange(today, norm.start(t), norm.end(t)),
      )
      .map((t) => t.id);

    return {
      periodo: elegido,
      trimestresDelPeriodo,
      allTriIds,
      activeTriIdsToday,
    };
  }, [periodos, trimestres, today, preferOpen]);

  const getTrimestreByDate = (dateISO: string) =>
    computed.trimestresDelPeriodo.find((t) =>
      inRange(dateISO, norm.start(t), norm.end(t)),
    );

  const isTrimestreClosed = (trimestreId?: number): boolean | undefined => {
    if (!trimestreId) return undefined;
    const t = computed.trimestresDelPeriodo.find((x) => x.id === trimestreId);
    return t ? !!norm.closed(t) : undefined;
  };

  return {
    loading,
    error,
    periodoEscolarId: computed.periodo?.id,
    periodoEscolar: computed.periodo,
    trimestres, // crudo
    trimestresDelPeriodo: computed.trimestresDelPeriodo,
    triIds: computed.allTriIds,
    activeTriIdsToday: computed.activeTriIdsToday,
    hoyISO: today,
    getTrimestreByDate,
    isTrimestreClosed,
  };
}
// hooks/useFamilyAlumnos.ts
"use client";

import { useEffect, useState } from "react";
import { api } from "@/services/api";
import { useAuth } from "@/hooks/useAuth";
import type { AlumnoLiteDTO } from "@/types/api-generated";

export function useFamilyAlumnos() {
  const { user } = useAuth();
  // En tu AuthContext ven√≠as usando user.personaId para "persona" asociada.
  // Para familiares, asumimos que personaId === familiarId.
  const familiarId = user?.personaId ?? null;

  const [loading, setLoading] = useState(true);
  const [alumnos, setAlumnos] = useState<AlumnoLiteDTO[]>([]);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    let mounted = true;
    (async () => {
      try {
        if (!familiarId) {
          if (mounted) {
            setAlumnos([]);
            setLoading(false);
          }
          return;
        }
        setLoading(true);
        const res = await api.familiaresAlumnos.byFamiliarId(familiarId);
        if (mounted) {
          setAlumnos(res.data ?? []);
          setError(null);
        }
      } catch (e: any) {
        if (mounted) setError(e?.message ?? "Error cargando hijos");
      } finally {
        if (mounted) setLoading(false);
      }
    })();

    return () => {
      mounted = false;
    };
  }, [familiarId]);

  return { loading, error, alumnos };
}
// src/hooks/useProtectedRoute.ts
"use client";

import { useEffect, useMemo } from "react";
import { useRouter } from "next/navigation";
import { useAuth } from "@/hooks/useAuth";
import { UserRole } from "@/types/api-generated";
import { normalizeRole } from "@/lib/auth-roles";

type Options = {
  allowed?: UserRole[]; // roles permitidos para esta p√°gina
  fallback?: string; // a d√≥nde enviar si no tiene rol permitido (default: "/dashboard")
  loginPath?: string; // ruta del login (tu caso: "/")
  selectRolePath?: string; // ruta del selector de rol (default: "/select-rol")
  autoselectSingleRole?: boolean; // si true: autoselecciona cuando hay 1 solo rol (default: true)
};

export function useProtectedRoute({
  allowed,
  fallback = "/dashboard",
  loginPath = "/", // üëà tu login est√° en "/"
  selectRolePath = "/select-rol",
  autoselectSingleRole = true,
}: Options = {}) {
  const {
    user,
    loading,
    roles: ctxRoles,
    selectedRole,
    setSelectedRole,
    hasRole,
  } = useAuth();
  const router = useRouter();

  // Normalizamos roles del usuario por si necesit√°s leerlos ac√°
  const roles = useMemo<UserRole[]>(
    () =>
      Array.from(
        new Set((user?.roles ?? []).map(normalizeRole).filter(Boolean)),
      ) as UserRole[],
    [user],
  );

  useEffect(() => {
    if (loading) return;

    // 1) Sin sesi√≥n -> login (/)
    if (!user) {
      router.replace(loginPath);
      return;
    }

    // 2) Tiene 2+ roles pero no eligi√≥ -> select-rol
    if (roles.length > 1 && !selectedRole) {
      router.replace(selectRolePath);
      return;
    }

    // 3) Tiene 1 solo rol y no eligi√≥ -> autoseleccionar (si est√° habilitado)
    if (roles.length === 1 && !selectedRole && autoselectSingleRole) {
      setSelectedRole(roles[0]);
      // refresh opcional si necesit√°s re-hidratar men√∫s/permisos ya mismo
      router.refresh();
      return;
    }

    // 4) Chequeo de autorizaci√≥n por rol (si se pidi√≥)
    if (allowed?.length) {
      const canAccess = allowed.some((r) => hasRole(r));
      if (!canAccess) {
        router.replace(fallback);
        return;
      }
    }
  }, [
    loading,
    user,
    roles,
    selectedRole,
    setSelectedRole,
    allowed,
    fallback,
    loginPath,
    selectRolePath,
    autoselectSingleRole,
    hasRole,
    router,
  ]);
}
import { useState } from "react";
import { validateStep1, Step1Data } from "@/lib/form-utils";

export interface WizardData extends Step1Data {
  escuelaActual: string;
  domicilio: string;
  nacionalidad: string;
  genero: string;
  estadoCivil: string;
  telefono: string;
  celular: string;
  emailContacto: string;
  familiares: any[];
  dispositivosDisponibles: string;
  idiomasHabladosHogar: string;
  enfermedadesAlergias: string;
  medicacionHabitual: string;
  limitacionesFisicasNeurologicas: string;
  tratamientosTerapeuticos: string;
  usoAyudasMovilidad: boolean;
  coberturaMedica: string;
  observacionesAdicionalesSalud: string;
}

export function useWizard(initial: WizardData) {
  const [data, setData] = useState(initial);
  const [step, setStep] = useState(1);
  const [error, setError] = useState<string | null>(null);

  function change<Field extends keyof WizardData>(
    field: Field,
    val: WizardData[Field],
  ) {
    setData((d) => ({ ...d, [field]: val }));
  }

  function next() {
    if (step === 1) {
      const err = validateStep1(data);
      if (err) {
        setError(err);
        return;
      }
    }
    setError(null);
    setStep((s) => s + 1);
  }

  function prev() {
    setError(null);
    setStep((s) => Math.max(1, s - 1));
  }

  return { data, step, error, change, next, prev };
}
// src/hooks/useRecentMessages.ts
"use client";
import { useEffect, useState } from "react";
import { api } from "@/services/api";

type RecentItem = {
  userId: number;
  nombre: string;
  lastMessage: string;
  at: string;
};

export function useRecentMessages(limit = 5) {
  const [items, setItems] = useState<RecentItem[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    let alive = true;
    (async () => {
      try {
        setLoading(true);
        const active = (await api.chat.getActiveChats()).data ?? [];
        const enriched = await Promise.all(
          active.slice(0, limit).map(async (c: any) => {
            const hist =
              (await api.chat.history(c.id ?? c.userId, { limit: 1 })).data ??
              [];
            const last = hist[hist.length - 1];
            return {
              userId: c.id ?? c.userId,
              nombre: c.nombre ?? c.email ?? `Usuario ${c.id ?? c.userId}`,
              lastMessage: last?.contenido ?? last?.message ?? "",
              at: last?.fechaEnvio ?? last?.sentAt ?? "",
            } as RecentItem;
          }),
        );
        if (alive) setItems(enriched);
      } finally {
        if (alive) setLoading(false);
      }
    })();
    return () => {
      alive = false;
    };
  }, [limit]);

  return { items, loading };
}
"use client";
import { useEffect, useMemo, useState } from "react";
import { api } from "@/services/api";
import type {
  TrimestreDTO,
  JornadaAsistenciaDTO,
  DetalleAsistenciaDTO,
  DiaNoHabilDTO,
  SeccionDTO,
  AsignacionDocenteSeccionDTO,
  AlumnoLiteDTO,
} from "@/types/api-generated";
import { toast } from "sonner";

export function useAsistenciasData() {
  const [loading, setLoading] = useState(true);
  const [trimestres, setTrimestres] = useState<TrimestreDTO[]>([]);
  const [secciones, setSecciones] = useState<SeccionDTO[]>([]);
  const [asignaciones, setAsignaciones] = useState<
    AsignacionDocenteSeccionDTO[]
  >([]);
  const [diasNoHabiles, setDiasNoHabiles] = useState<DiaNoHabilDTO[]>([]);

  // cache por secci√≥n/fecha
  const [alumnosBySeccion, setAlumnosBySeccion] = useState<
    Record<string, AlumnoLiteDTO[]>
  >({});
  const [jornadas, setJornadas] = useState<JornadaAsistenciaDTO[]>([]);
  const [detalles, setDetalles] = useState<DetalleAsistenciaDTO[]>([]);

  useEffect(() => {
    (async () => {
      try {
        const [tri, secs, asig, dias] = await Promise.all([
          api.trimestres.list().then((r) => r.data),
          api.secciones.list().then((r) => r.data),
          api.asignacionDocenteSeccion.list().then((r) =>
            (r.data ?? []).map((a: any) => ({
              ...a,
              empleadoId: a.empleadoId ?? a.personalId ?? a.docenteId,
            })),
          ),
          api.diasNoHabiles.list().then((r) => r.data),
        ]);
        setTrimestres(tri);
        setSecciones(secs);
        setAsignaciones(asig);
        setDiasNoHabiles(dias);
      } catch {
        toast.error("Error cargando datos base");
      } finally {
        setLoading(false);
      }
    })();
  }, []);

  const loadAlumnosSeccion = async (seccionId: number, fechaISO?: string) => {
    const key = `${seccionId}_${fechaISO ?? ""}`;
    if (alumnosBySeccion[key]) return alumnosBySeccion[key];
    const { data } = await api.secciones.alumnos(seccionId, fechaISO);
    setAlumnosBySeccion((m) => ({ ...m, [key]: data }));
    return data;
  };

  const searchJornadas = async (params: {
    seccionId?: number;
    trimestreId?: number;
    from?: string;
    to?: string;
  }) => {
    const { data } = await api.jornadasAsistencia.search(params);
    setJornadas(data);
    return data;
  };

  const loadDetallesByJornada = async (jornadaId: number) => {
    const { data } = await api.detallesAsistencia.search({ jornadaId });
    setDetalles((prev) => {
      // merge simple
      const others = prev.filter((p) => p.jornadaId !== jornadaId);
      return [...others, ...data];
    });
    return data;
  };

  return {
    loading,
    trimestres,
    secciones,
    asignaciones,
    diasNoHabiles,
    alumnosBySeccion,
    jornadas,
    detalles,
    loadAlumnosSeccion,
    searchJornadas,
    loadDetallesByJornada,
    refreshBase: async () => {
      const [tri, dias] = await Promise.all([
        api.trimestres.list().then((r) => r.data),
        api.diasNoHabiles.list().then((r) => r.data),
      ]);
      setTrimestres(tri);
      setDiasNoHabiles(dias);
    },
  };
}
// hooks/useAcumuladoSeccion.ts
"use client";
import { useEffect, useState } from "react";
import { api } from "@/services/api";
import type { AsistenciaAcumuladoDTO } from "@/types/api-generated";

export function useAcumuladoSeccion(seccionId: number) {
  const [loading, setLoading] = useState(true);
  const [data, setData] = useState<AsistenciaAcumuladoDTO | null>(null);

  useEffect(() => {
    const hoy = new Date().toISOString().slice(0, 10);
    (async () => {
      try {
        const res = await api.asistencias.acumuladoSeccion(
          seccionId,
          "1970-01-01", // desde muy atr√°s
          hoy,
        );
        setData(res.data);
      } finally {
        setLoading(false);
      }
    })();
  }, [seccionId]);

  const porcentaje = data
    ? Math.round(
        (data.presentes / Math.max(1, data.presentes + data.ausentes)) * 100,
      )
    : 0;

  return { loading, data, porcentaje };
}
import { useState, useEffect, useRef, useCallback } from "react";
import { Client, StompSubscription } from "@stomp/stompjs";
import SockJS from "sockjs-client";
import type { ChatMessageDTO } from "@/types/api-generated";
import { useAuth } from "./useAuth";
import { api } from "@/services/api";

const normalizeMessage = (msg: any): ChatMessageDTO => ({
  id: msg.id,
  emisorId: msg.emisorId ?? msg.emisor ?? 0,
  receptorId: msg.receptorId ?? msg.receptor ?? 0,
  contenido: msg.contenido,
  fechaEnvio: msg.fechaEnvio ?? new Date().toISOString(),
  leido: msg.leido ?? false,
});

export type ConnectionStatus = "connecting" | "connected" | "disconnected";

export default function useChatSocket() {
  const [messages, setMessages] = useState<ChatMessageDTO[]>([]);
  const [connected, setConnected] = useState(false);
  const [connectionStatus, setConnectionStatus] =
    useState<ConnectionStatus>("connecting");
  const { user } = useAuth();

  const client = useRef<Client | null>(null);
  const subscriptions = useRef<StompSubscription[]>([]);

  // üîπ Conectar WebSocket
  const connect = useCallback(() => {
    if (client.current?.connected) return;

    setConnectionStatus("connecting");
    console.log("üîå Intentando conectar WebSocket...");

    const socket = new SockJS("http://localhost:8080/ws"); // Aseg√∫rate que coincida con tu backend
    const stompClient = new Client({
      webSocketFactory: () => socket,
      reconnectDelay: 1000,
      debug: (str) => console.log("STOMP:", str),
    });

    stompClient.onConnect = (frame) => {
      console.log("‚úÖ WebSocket conectado. Frame:", frame);
      console.log("üõé Suscribi√©ndome a /user/queue/messages");
      setConnected(true);
      setConnectionStatus("connected");

      // Suscripci√≥n a mensajes
      subscriptions.current.push(
        stompClient.subscribe("/user/queue/messages", (message) => {
          if (!message.body) return;
          const msg = normalizeMessage(JSON.parse(message.body));
          console.log("üì• Mensaje recibido del backend:", msg);

          setMessages((prev) => {
            // Buscar mensaje optimista para reemplazar
            const idx = prev.findIndex(
              (m) =>
                (m?.id ?? 0) < 0 &&
                m.emisorId === msg.emisorId &&
                m.receptorId === msg.receptorId &&
                m.contenido === msg.contenido,
            );

            if (idx >= 0) {
              // Reemplaza el optimista por el real
              const newMessages = [...prev];
              newMessages[idx] = msg;
              return newMessages;
            }

            // Si no es optimista, agregar normalmente
            return [...prev, msg];
          });
        }),
      );

      // Suscripci√≥n a los ACKs del emisor
      subscriptions.current.push(
        stompClient.subscribe("/user/queue/ack", (msg) => {
          if (!msg.body) return;
          console.log("üîî ACK recibido:", msg.body);
          const ackMessage: ChatMessageDTO = JSON.parse(msg.body);
          // Aqu√≠ actualizas tu array de mensajes reemplazando
          // el optimista (id < 0) por el que vino del servidor:
          setMessages((prev) => {
            const idx = prev.findIndex(
              (m) =>
                m.id < 0 &&
                m.receptorId === ackMessage.receptorId &&
                m.contenido === ackMessage.contenido,
            );
            if (idx === -1) return prev;
            const updated = [...prev];
            updated[idx] = ackMessage;
            return updated;
          });
        }),
      );

      // Suscripci√≥n a errores
      subscriptions.current.push(
        stompClient.subscribe("/user/queue/errors", (message) => {
          console.error("‚ö†Ô∏è Error desde el servidor:", message.body);
        }),
      );
    };

    stompClient.onStompError = (frame) => {
      console.error("STOMP Error:", frame);
    };

    stompClient.onWebSocketClose = () => {
      console.warn("‚ùå WebSocket desconectado");
      setConnected(false);
      setConnectionStatus("disconnected");
    };

    stompClient.activate();
    client.current = stompClient;
  }, []);

  // üîπ Reconectar manual
  const reconnect = () => {
    disconnect();
    connect();
  };

  // üîπ Desconectar limpiamente
  const disconnect = () => {
    subscriptions.current.forEach((sub) => sub.unsubscribe());
    subscriptions.current = [];
    client.current?.deactivate();
    client.current = null;
    setConnected(false);
    setConnectionStatus("disconnected");
  };

  // üîπ Enviar mensaje

  const sendMessage = (receptorId: number, contenido: string) => {
    if (!client.current || !connected) {
      console.warn("‚ö†Ô∏è No se pudo enviar, WebSocket no conectado");
      return false;
    }

    // 1) Armar el mensaje optimista
    const optimisticMsg: ChatMessageDTO = {
      id: -Date.now(),
      emisorId: user?.id ?? 0,
      receptorId,
      contenido,
      fechaEnvio: new Date().toISOString(),
      leido: false,
    };

    // 2) Insertarlo inmediatamente en el estado
    setMessages((prev) => [...prev, optimisticMsg]);

    // 3) Publicar por STOMP
    const payload = { receptorId, contenido };
    console.log("üì§ Enviando mensaje:", payload);
    client.current.publish({
      destination: "/app/chat.send",
      body: JSON.stringify(payload),
    });

    return true;
  };

  // üîπ Marcar mensajes como le√≠dos
  const markRead = async (otherUserId: number) => {
    try {
      console.log("üì° Marcando mensajes como le√≠dos de usuario:", otherUserId);
      await fetch(`http://localhost:8080/api/chat/mark-read/${otherUserId}`, {
        method: "POST",
        credentials: "include",
      });

      setMessages((prev) =>
        prev.map((msg) =>
          msg.emisorId === otherUserId ? { ...msg, leido: true } : msg,
        ),
      );
    } catch (err) {
      console.error("Error al marcar mensajes como le√≠dos:", err);
    }
  };

  // üîπ Cargar historial desde la API
  const loadHistory = async (otherUserId: number) => {
    try {
      console.log("üì° Cargando historial de usuario:", otherUserId);
      const { data } = await api.chat.history(otherUserId);
      setMessages(data.map(normalizeMessage));
    } catch (err) {
      console.error("Error al cargar historial:", err);
      setMessages([]); // Evitar que queden mensajes viejos si falla
    }
  };
  // üîπ Conectar al montar
  useEffect(() => {
    connect();
    return () => disconnect();
  }, [connect]);

  return {
    messages,
    sendMessage,
    connected,
    connectionStatus,
    reconnect,
    markRead,
    loadHistory,
  };
}

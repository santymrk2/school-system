"use client";

import { useEffect, useMemo, useState } from "react";
import { api } from "@/services/api";
import { useAuth } from "@/context/AuthContext";
import type {
  SeccionDTO,
  AsignacionDocenteSeccionDTO,
} from "@/types/api-generated";

/**
 * Retorna las secciones asignadas al docente (usuario.personaId).
 * Filtra del endpoint de asignaciones y cruza con /secciones.
 */
export function useTeacherSecciones() {
  const { user } = useAuth();
  const personalId = user?.personaId ?? null;

  const [loading, setLoading] = useState(true);
  const [secciones, setSecciones] = useState<SeccionDTO[]>([]);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    let mounted = true;
    (async () => {
      if (!personalId) {
        setLoading(false);
        setSecciones([]);
        return;
      }
      try {
        setLoading(true);

        // 1) Traigo TODAS las asignaciones y me quedo con las del personalId
        const asigResp = await api.asignacionDocenteSeccion.list();
        const asignaciones = (asigResp.data ??
          []) as AsignacionDocenteSeccionDTO[];

        // Ojo: tu DTO usa "docenteId". Si tu backend expone "personalId", cambiá la línea de abajo.
        const seccionIds = Array.from(
          new Set(
            asignaciones
              .filter((a) => a.personalId === personalId)
              .map((a) => a.seccionId),
          ),
        );

        if (seccionIds.length === 0) {
          if (mounted) {
            setSecciones([]);
            setLoading(false);
          }
          return;
        }

        // 2) Para evitar muchos requests, traigo /secciones y filtro
        const secResp = await api.secciones.list();
        const todas = secResp.data ?? [];
        const mias = todas.filter((s) => seccionIds.includes(s.id));

        if (mounted) {
          setSecciones(mias);
          setError(null);
        }
      } catch (e: any) {
        if (mounted) setError(e?.message ?? "Error cargando secciones");
      } finally {
        if (mounted) setLoading(false);
      }
    })();
    return () => {
      mounted = false;
    };
  }, [personalId]);

  return { loading, error, secciones };
}
// src/hooks/academico/useCatalogosCierre.ts
"use client";

import { useEffect, useMemo, useState } from "react";
import { api } from "@/services/api/index";

export function useCatalogosCierre(seccionId?: number) {
  const [loading, setLoading] = useState(true);
  const [trimestres, setTrimestres] = useState<any[]>([]);
  const [seccionMaterias, setSeccionMaterias] = useState<any[]>([]);
  const [materias, setMaterias] = useState<any[]>([]);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    let alive = true;
    (async () => {
      try {
        setLoading(true);
        setError(null);
        const [tri, sms] = await Promise.all([
          api.trimestres.list().then((r) => r.data ?? []),
          api.seccionMaterias.list().then((r) => r.data ?? []),
        ]);
        if (!alive) return;
        setTrimestres(tri);
        setSeccionMaterias(sms);

        // Si no tenés endpoint de materias, omití esto o resolvé nombre desde el DTO de SeccionMateria
        // setMaterias(await api.materias.list()...);
      } catch (e: any) {
        if (alive) setError(e?.message ?? "No se pudo cargar catálogos");
      } finally {
        if (alive) setLoading(false);
      }
    })();
    return () => {
      alive = false;
    };
  }, []);

  const seccionMateriaIds = useMemo(
    () =>
      new Set(
        seccionMaterias
          .filter((sm: any) => (sm.seccionId ?? sm.seccion?.id) === seccionId)
          .map((sm: any) => sm.id),
      ),
    [seccionMaterias, seccionId],
  );

  // Si tu DTO de SeccionMateria ya trae materia.nombre, úsalo directo en la vista
  return {
    loading,
    error,
    trimestres,
    seccionMaterias,
    materias,
    seccionMateriaIds,
  };
}
// src/hooks/academico/useSeccionAlumnos.ts
"use client";

import { useEffect, useState } from "react";
import { api } from "@/services/api/index";

export function useSeccionAlumnos(seccionId?: number, fecha?: string) {
  const [loading, setLoading] = useState(false);
  const [alumnos, setAlumnos] = useState<any[]>([]);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!seccionId) return;
    let alive = true;
    (async () => {
      try {
        setLoading(true);
        setError(null);
        const { data } = await api.secciones.alumnos(seccionId, fecha);
        if (!alive) return;
        setAlumnos(data ?? []);
      } catch (e: any) {
        if (alive) setError(e?.message ?? "No se pudo cargar alumnos");
      } finally {
        if (alive) setLoading(false);
      }
    })();
    return () => {
      alive = false;
    };
  }, [seccionId, fecha]);

  return { loading, alumnos, error };
}
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }
"use client";
import { useEffect, useMemo, useState } from "react";
import { api } from "@/services/api";
import type { AlumnoLiteDTO, AlumnoDTO } from "@/types/api-generated";

export type StudentVM = {
  matriculaId: number;
  alumnoId: number;
  nombreCompleto: string;
  documento?: string | null; // backend: "documento" ; fallback a "dni" si tu DTO FE lo tiene
  email?: string | null;
  telefono?: string | null;
  // agregá acá lo que tu backend exponga en AlumnoDTO/PersonaDTO
};

export function useSeccionAlumnosFull(seccionId: number, fechaISO: string) {
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [items, setItems] = useState<StudentVM[]>([]);

  useEffect(() => {
    let alive = true;
    (async () => {
      setLoading(true);
      setError(null);
      try {
        // 1) roster por sección/fecha (AlumnoLiteDTO)
        const { data: lite } = await api.seccionesAlumnos.bySeccionId(
          seccionId,
          fechaISO,
        );

        // 2) detalle de cada alumno (AlumnoDTO)
        const uniqueAlumnoIds = Array.from(
          new Set((lite ?? []).map((l) => l.alumnoId)),
        );
        const details = await Promise.all(
          uniqueAlumnoIds.map((id) =>
            api.alumnos
              .getById(id)
              .then((r) => r.data as AlumnoDTO)
              .catch(() => null),
          ),
        );
        const byId = new Map<number, AlumnoDTO | null>();
        uniqueAlumnoIds.forEach((id, i) => byId.set(id, details[i]));

        // 3) Componer VM
        const vm: StudentVM[] = (lite ?? []).map((l: AlumnoLiteDTO) => {
          const d = byId.get(l.alumnoId) || null;
          const documento = (d as any)?.documento ?? (d as any)?.dni ?? null;
          return {
            matriculaId: l.matriculaId,
            alumnoId: l.alumnoId,
            nombreCompleto: l.nombreCompleto,
            documento,
            email: (d as any)?.emailContacto ?? (d as any)?.email ?? null,
            telefono: (d as any)?.telefono ?? null,
          };
        });

        if (alive) setItems(vm);
      } catch (e: any) {
        if (alive) setError(e?.message ?? "No se pudo cargar el roster.");
      } finally {
        if (alive) setLoading(false);
      }
    })();
    return () => {
      alive = false;
    };
  }, [seccionId, fechaISO]);

  const count = items.length;
  return { loading, error, items, count };
}
"use client";

import { useEffect, useMemo, useState } from "react";
import { api } from "@/services/api";
import { useViewerScope } from "./useViewerScope";
import type {
  SeccionDTO,
  AsignacionDocenteSeccionDTO,
  PersonalDTO,
} from "@/types/api-generated";

function vigente(
  desde?: string | null,
  hasta?: string | null,
  hoyISO?: string,
) {
  const today = hoyISO ?? new Date().toISOString().slice(0, 10);
  const okD = !desde || today >= desde;
  const okH = !hasta || today <= hasta;
  return okD && okH;
}

export function useScopedSecciones(opts?: {
  fecha?: string; // YYYY-MM-DD (default hoy)
  periodoEscolarId?: number; // filtra por período activo si viene
  includeTitular?: boolean; // si querés mapa de titular por sección
}) {
  const { type, personaId } = useViewerScope();
  const fecha = opts?.fecha ?? new Date().toISOString().slice(0, 10);
  const periodoEscolarId = opts?.periodoEscolarId;
  const includeTitular = !!opts?.includeTitular;

  const [loading, setLoading] = useState(true);
  const [secciones, setSecciones] = useState<SeccionDTO[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [titularBySeccionId, setTitularBySeccionId] = useState<
    Map<number, string>
  >(new Map());

  useEffect(() => {
    let alive = true;
    (async () => {
      try {
        setLoading(true);
        setError(null);

        // STAFF → todas las secciones (opcional: filtrar por período)
        if (type === "staff") {
          const [secs, asig, pers] = await Promise.all([
            api.secciones.list().then((r) => r.data ?? []),
            includeTitular
              ? api.asignacionDocenteSeccion.list().then((r) => r.data ?? [])
              : Promise.resolve([]),
            includeTitular
              ? api.personal.list().then((r) => r.data ?? [])
              : Promise.resolve([]),
          ]);
          const filtradas =
            periodoEscolarId == null
              ? secs
              : secs.filter(
                  (s: any) =>
                    (s.periodoEscolarId ??
                      s.periodoId ??
                      s.periodoEscolar?.id) === periodoEscolarId,
                );

          if (includeTitular) {
            const map = new Map<number, string>();
            const hoy = fecha;
            for (const a of asig as AsignacionDocenteSeccionDTO[]) {
              const rol = String((a as any).rol ?? "").toUpperCase();
              if (rol !== "MAESTRO_TITULAR") continue;
              if (
                !vigente(
                  (a as any).vigenciaDesde,
                  (a as any).vigenciaHasta,
                  hoy,
                )
              )
                continue;
              const sid = (a as any).seccionId ?? (a as any).seccion?.id;
              const pid = (a as any).personalId ?? (a as any).personal?.id;
              if (!sid || !pid) continue;
              const p = (pers as PersonalDTO[]).find((pp) => pp.id === pid);
              if (p)
                map.set(sid, `${p.apellido ?? ""} ${p.nombre ?? ""}`.trim());
            }
            if (alive) setTitularBySeccionId(map);
          }

          if (alive) setSecciones(filtradas);
          return;
        }

        // TEACHER → asignaciones del docente (vigentes en fecha)
        if (type === "teacher") {
          if (!personaId) {
            if (alive) setSecciones([]);
            return;
          }

          // Preferir endpoint “vigentes”
          let asigs: AsignacionDocenteSeccionDTO[] = [];
          try {
            // @ts-ignore
            const r = await api.asignacionDocenteSeccion.byPersonalVigentes(
              personaId,
              fecha,
            );
            asigs = r.data ?? [];
          } catch {
            const r = await api.asignacionDocenteSeccion.list();
            const todos = r.data ?? [];
            asigs = todos.filter(
              (a: any) =>
                (a.personalId ?? a.docenteId) === personaId &&
                vigente(
                  (a as any).vigenciaDesde,
                  (a as any).vigenciaHasta,
                  fecha,
                ),
            );
          }

          const ids = Array.from(
            new Set(
              asigs
                .map((a: any) => a.seccionId ?? a.seccion?.id)
                .filter(Boolean),
            ),
          ) as number[];

          if (ids.length === 0) {
            if (alive) setSecciones([]);
            return;
          }

          let secs = (await api.secciones.list()).data ?? [];
          secs = secs.filter((s) => ids.includes(s.id));

          if (periodoEscolarId != null) {
            secs = secs.filter(
              (s: any) =>
                (s.periodoEscolarId ?? s.periodoId ?? s.periodoEscolar?.id) ===
                periodoEscolarId,
            );
          }

          if (alive) setSecciones(secs);
          return;
        }

        // FAMILY / GUEST → acá no devolvemos secciones (family ve hijos)
        if (alive) setSecciones([]);
      } catch (e: any) {
        if (alive) setError(e?.message ?? "Error cargando secciones");
      } finally {
        if (alive) setLoading(false);
      }
    })();
    return () => {
      alive = false;
    };
  }, [type, personaId, fecha, periodoEscolarId, includeTitular]);

  return { loading, error, secciones, titularBySeccionId };
}
"use client";

import { useMemo } from "react";
import { useViewerScope } from "./useViewerScope";
import { useActivePeriod } from "./useActivePeriod";
import { useScopedSecciones } from "./useScopedSecciones";
import { useFamilyAlumnos } from "@/hooks/useFamilyAlumnos";

/**
 * Unifica la “pantalla índice”:
 * - staff / teacher → secciones visibles
 * - family → hijos (alumnos)
 *
 * Lo podés usar igual en módulos de exámenes, asistencias y accidentes.
 */
export function useScopedIndex(opts?: {
  includeTitularSec?: boolean; // útil para staff (mostrar titular)
}) {
  const { type } = useViewerScope();
  const {
    loading: loadingPeriodo,
    periodoEscolarId,
    hoyISO,
  } = useActivePeriod();

  // Secciones para staff/teacher
  const {
    loading: loadingSecs,
    error: errorSecs,
    secciones,
    titularBySeccionId,
  } = useScopedSecciones({
    fecha: hoyISO,
    periodoEscolarId: periodoEscolarId ?? undefined,
    includeTitular: !!opts?.includeTitularSec,
  });

  // Hijos para family
  const {
    alumnos,
    loading: loadingHijos,
    error: errorHijos,
  } = useFamilyAlumnos?.() ?? {
    alumnos: [],
    loading: false,
    error: null,
  };

  const loading =
    loadingPeriodo || (type === "family" ? loadingHijos : loadingSecs);
  const error = type === "family" ? errorHijos : errorSecs;

  return useMemo(() => {
    if (type === "family") {
      return {
        scope: "family" as const,
        loading,
        error,
        hijos: alumnos, // array de AlumnoLiteDTO
        secciones: [] as any[], // vacío en family
        titularBySeccionId: new Map<number, string>(),
        periodoEscolarId,
        hoyISO,
      };
    }
    // staff / teacher
    return {
      scope: (type === "staff" ? "staff" : "teacher") as const,
      loading,
      error,
      hijos: [] as any[], // vacío si no es family
      secciones, // array de SeccionDTO
      titularBySeccionId,
      periodoEscolarId,
      hoyISO,
    };
  }, [
    type,
    loading,
    error,
    alumnos,
    secciones,
    titularBySeccionId,
    periodoEscolarId,
    hoyISO,
  ]);
}
"use client";

import { useMemo } from "react";
import { useAuth } from "@/context/AuthContext";

const ROLES_STAFF = new Set(["ADMIN", "DIRECTOR", "SECRETARY"]);

export function useViewerScope() {
  const { user } = useAuth();
  const roles = (user?.roles ?? []).map((r: any) => String(r).toUpperCase());

  return useMemo(() => {
    const isStaff = roles.some((r) => ROLES_STAFF.has(r));
    const isTeacher = roles.includes("TEACHER");
    const isFamily = roles.includes("FAMILY");

    // prioridad: si es staff, lo tratamos como staff (aunque también sea teacher)
    const type: "staff" | "teacher" | "family" | "guest" = isStaff
      ? "staff"
      : isTeacher
        ? "teacher"
        : isFamily
          ? "family"
          : "guest";

    return {
      type,
      roles,
      // personaId = Personal.id para teacher, Familiar.id para family (según tu backend)
      personaId: user?.personaId ?? null,
      user,
    };
  }, [roles, user]);
}
"use client";

import { useEffect, useMemo, useState } from "react";
import { api } from "@/services/api";
import type { PeriodoEscolarDTO, TrimestreDTO } from "@/types/api-generated";

type UseActivePeriodOpts = {
  today?: string; // YYYY-MM-DD (para tests)
  preferOpen?: boolean; // prioriza período con trimestres abiertos hoy
};

function toLocalISODate(d = new Date()): string {
  const tzOffset = d.getTimezoneOffset();
  const local = new Date(d.getTime() - tzOffset * 60_000);
  return local.toISOString().slice(0, 10);
}

function normStart(t: TrimestreDTO): string {
  return ((t as any).fechaInicio ??
    (t as any).inicio ??
    "1900-01-01") as string;
}
function normEnd(t: TrimestreDTO): string {
  return ((t as any).fechaFin ?? (t as any).fin ?? "2999-12-31") as string;
}
function normPeriodoId(t: TrimestreDTO): number | undefined {
  return ((t as any).periodoEscolarId ?? (t as any).periodoId) as
    | number
    | undefined;
}
function inRange(date: string, from: string, to: string) {
  return date >= from && date <= to;
}

export function useActivePeriod(opts?: UseActivePeriodOpts) {
  const [periodos, setPeriodos] = useState<PeriodoEscolarDTO[]>([]);
  const [trimestres, setTrimestres] = useState<TrimestreDTO[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const preferOpen = opts?.preferOpen ?? true;
  const hoyISO = opts?.today ?? toLocalISODate();

  useEffect(() => {
    let alive = true;
    (async () => {
      try {
        setLoading(true);
        setError(null);
        const [per, tri] = await Promise.all([
          api.periodos.list().then((r) => r.data ?? []),
          api.trimestres.list().then((r) => r.data ?? []),
        ]);
        if (!alive) return;
        setPeriodos(per);
        setTrimestres(tri);
      } catch (e: any) {
        if (alive)
          setError(e?.message ?? "No se pudo cargar el calendario escolar");
      } finally {
        if (alive) setLoading(false);
      }
    })();
    return () => {
      alive = false;
    };
  }, []);

  const computed = useMemo(() => {
    if (!periodos.length || !trimestres.length) {
      return {
        periodo: undefined as PeriodoEscolarDTO | undefined,
        trimestresDelPeriodo: [] as TrimestreDTO[],
        allTriIds: [] as number[],
        activeTriIdsToday: [] as number[],
      };
    }

    const trisByPeriodo = new Map<number, TrimestreDTO[]>();
    for (const t of trimestres) {
      const pid = normPeriodoId(t);
      if (!pid) continue;
      const arr = trisByPeriodo.get(pid) ?? [];
      arr.push(t);
      trisByPeriodo.set(pid, arr);
    }

    let elegido: PeriodoEscolarDTO | undefined;
    if (preferOpen) {
      elegido = periodos.find((p) => {
        const ts = trisByPeriodo.get(p.id) ?? [];
        return ts.some(
          (t) => !t.cerrado && inRange(hoyISO, normStart(t), normEnd(t)),
        );
      });
    }
    if (!elegido) {
      elegido = [...periodos].sort(
        (a: any, b: any) => (b.anio ?? 0) - (a.anio ?? 0),
      )[0];
    }

    const trimestresDelPeriodo = elegido
      ? (trisByPeriodo.get(elegido.id) ?? [])
      : [];
    const allTriIds = trimestresDelPeriodo.map((t) => t.id);
    const activeTriIdsToday = trimestresDelPeriodo
      .filter((t) => !t.cerrado && inRange(hoyISO, normStart(t), normEnd(t)))
      .map((t) => t.id);

    return {
      periodo: elegido,
      trimestresDelPeriodo,
      allTriIds,
      activeTriIdsToday,
    };
  }, [periodos, trimestres, hoyISO, preferOpen]);

  const getTrimestreByDate = (dateISO: string) =>
    computed.trimestresDelPeriodo.find((t) =>
      inRange(dateISO, normStart(t), normEnd(t)),
    );

  const isTrimestreClosed = (trimestreId?: number) =>
    !!computed.trimestresDelPeriodo.find((t) => t.id === trimestreId)?.cerrado;

  return {
    loading,
    error,
    periodoEscolarId: computed.periodo?.id,
    periodoEscolar: computed.periodo,
    trimestres, // todos (crudo)
    trimestresDelPeriodo: computed.trimestresDelPeriodo,
    triIds: computed.allTriIds,
    activeTriIdsToday: computed.activeTriIdsToday,
    hoyISO,
    getTrimestreByDate,
    isTrimestreClosed,
  };
}
export { useAuth } from "@/context/AuthContext";
// hooks/useFamilyAlumnos.ts
"use client";

import { useEffect, useState } from "react";
import { api } from "@/services/api";
import { useAuth } from "@/context/AuthContext";
import type { AlumnoLiteDTO } from "@/types/api-generated";

export function useFamilyAlumnos() {
  const { user } = useAuth();
  // En tu AuthContext venías usando user.personaId para "persona" asociada.
  // Para familiares, asumimos que personaId === familiarId.
  const familiarId = user?.personaId ?? null;

  const [loading, setLoading] = useState(true);
  const [alumnos, setAlumnos] = useState<AlumnoLiteDTO[]>([]);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    let mounted = true;
    (async () => {
      try {
        if (!familiarId) {
          if (mounted) {
            setAlumnos([]);
            setLoading(false);
          }
          return;
        }
        setLoading(true);
        const res = await api.familiaresAlumnos.byFamiliarId(familiarId);
        if (mounted) {
          setAlumnos(res.data ?? []);
          setError(null);
        }
      } catch (e: any) {
        if (mounted) setError(e?.message ?? "Error cargando hijos");
      } finally {
        if (mounted) setLoading(false);
      }
    })();

    return () => {
      mounted = false;
    };
  }, [familiarId]);

  return { loading, error, alumnos };
}
// src/hooks/useProtectedRoute.ts
"use client";

import { useEffect, useMemo } from "react";
import { useRouter } from "next/navigation";
import { useAuth } from "@/context/AuthContext";
import { UserRole } from "@/types/api-generated";
import { normalizeRole } from "@/lib/auth-roles";

type Options = {
  allowed?: UserRole[]; // roles permitidos para esta página
  fallback?: string; // a dónde enviar si no tiene rol permitido (default: "/dashboard")
  loginPath?: string; // ruta del login (tu caso: "/")
  selectRolePath?: string; // ruta del selector de rol (default: "/select-rol")
  autoselectSingleRole?: boolean; // si true: autoselecciona cuando hay 1 solo rol (default: true)
};

export function useProtectedRoute({
  allowed,
  fallback = "/dashboard",
  loginPath = "/", // 👈 tu login está en "/"
  selectRolePath = "/select-rol",
  autoselectSingleRole = true,
}: Options = {}) {
  const {
    user,
    loading,
    roles: ctxRoles,
    selectedRole,
    setSelectedRole,
    hasRole,
  } = useAuth();
  const router = useRouter();

  // Normalizamos roles del usuario por si necesitás leerlos acá
  const roles = useMemo<UserRole[]>(
    () =>
      Array.from(
        new Set((user?.roles ?? []).map(normalizeRole).filter(Boolean)),
      ) as UserRole[],
    [user],
  );

  useEffect(() => {
    if (loading) return;

    // 1) Sin sesión -> login (/)
    if (!user) {
      router.replace(loginPath);
      return;
    }

    // 2) Tiene 2+ roles pero no eligió -> select-rol
    if (roles.length > 1 && !selectedRole) {
      router.replace(selectRolePath);
      return;
    }

    // 3) Tiene 1 solo rol y no eligió -> autoseleccionar (si está habilitado)
    if (roles.length === 1 && !selectedRole && autoselectSingleRole) {
      setSelectedRole(roles[0]);
      // refresh opcional si necesitás re-hidratar menús/permisos ya mismo
      router.refresh();
      return;
    }

    // 4) Chequeo de autorización por rol (si se pidió)
    if (allowed?.length) {
      const canAccess = allowed.some((r) => hasRole(r));
      if (!canAccess) {
        router.replace(fallback);
        return;
      }
    }
  }, [
    loading,
    user,
    roles,
    selectedRole,
    setSelectedRole,
    allowed,
    fallback,
    loginPath,
    selectRolePath,
    autoselectSingleRole,
    hasRole,
    router,
  ]);
}
import { useState } from "react";
import { validateStep1, Step1Data } from "@/lib/form-utils";

export interface WizardData extends Step1Data {
  escuelaActual: string;
  domicilio: string;
  nacionalidad: string;
  genero: string;
  estadoCivil: string;
  telefono: string;
  celular: string;
  emailContacto: string;
  familiares: any[];
  dispositivosDisponibles: string;
  idiomasHabladosHogar: string;
  enfermedadesAlergias: string;
  medicacionHabitual: string;
  limitacionesFisicasNeurologicas: string;
  tratamientosTerapeuticos: string;
  usoAyudasMovilidad: boolean;
  coberturaMedica: string;
  observacionesAdicionalesSalud: string;
}

export function useWizard(initial: WizardData) {
  const [data, setData] = useState(initial);
  const [step, setStep] = useState(1);
  const [error, setError] = useState<string | null>(null);

  function change<Field extends keyof WizardData>(
    field: Field,
    val: WizardData[Field],
  ) {
    setData((d) => ({ ...d, [field]: val }));
  }

  function next() {
    if (step === 1) {
      const err = validateStep1(data);
      if (err) {
        setError(err);
        return;
      }
    }
    setError(null);
    setStep((s) => s + 1);
  }

  function prev() {
    setError(null);
    setStep((s) => Math.max(1, s - 1));
  }

  return { data, step, error, change, next, prev };
}
"use client";
import { useEffect, useMemo, useState } from "react";
import { api } from "@/services/api";
import type {
  TrimestreDTO,
  JornadaAsistenciaDTO,
  DetalleAsistenciaDTO,
  DiaNoHabilDTO,
  SeccionDTO,
  AsignacionDocenteSeccionDTO,
  AlumnoLiteDTO,
} from "@/types/api-generated";
import { toast } from "sonner";

export function useAsistenciasData() {
  const [loading, setLoading] = useState(true);
  const [trimestres, setTrimestres] = useState<TrimestreDTO[]>([]);
  const [secciones, setSecciones] = useState<SeccionDTO[]>([]);
  const [asignaciones, setAsignaciones] = useState<
    AsignacionDocenteSeccionDTO[]
  >([]);
  const [diasNoHabiles, setDiasNoHabiles] = useState<DiaNoHabilDTO[]>([]);

  // cache por sección/fecha
  const [alumnosBySeccion, setAlumnosBySeccion] = useState<
    Record<string, AlumnoLiteDTO[]>
  >({});
  const [jornadas, setJornadas] = useState<JornadaAsistenciaDTO[]>([]);
  const [detalles, setDetalles] = useState<DetalleAsistenciaDTO[]>([]);

  useEffect(() => {
    (async () => {
      try {
        const [tri, secs, asig, dias] = await Promise.all([
          api.trimestres.list().then((r) => r.data),
          api.secciones.list().then((r) => r.data),
          api.asignacionDocenteSeccion.list().then((r) => r.data),
          api.diasNoHabiles.list().then((r) => r.data),
        ]);
        setTrimestres(tri);
        setSecciones(secs);
        setAsignaciones(asig);
        setDiasNoHabiles(dias);
      } catch {
        toast.error("Error cargando datos base");
      } finally {
        setLoading(false);
      }
    })();
  }, []);

  const loadAlumnosSeccion = async (seccionId: number, fechaISO?: string) => {
    const key = `${seccionId}_${fechaISO ?? ""}`;
    if (alumnosBySeccion[key]) return alumnosBySeccion[key];
    const { data } = await api.secciones.alumnos(seccionId, fechaISO);
    setAlumnosBySeccion((m) => ({ ...m, [key]: data }));
    return data;
  };

  const searchJornadas = async (params: {
    seccionId?: number;
    trimestreId?: number;
    from?: string;
    to?: string;
  }) => {
    const { data } = await api.jornadasAsistencia.search(params);
    setJornadas(data);
    return data;
  };

  const loadDetallesByJornada = async (jornadaId: number) => {
    const { data } = await api.detallesAsistencia.search({ jornadaId });
    setDetalles((prev) => {
      // merge simple
      const others = prev.filter((p) => p.jornadaId !== jornadaId);
      return [...others, ...data];
    });
    return data;
  };

  return {
    loading,
    trimestres,
    secciones,
    asignaciones,
    diasNoHabiles,
    alumnosBySeccion,
    jornadas,
    detalles,
    loadAlumnosSeccion,
    searchJornadas,
    loadDetallesByJornada,
    refreshBase: async () => {
      const [tri, dias] = await Promise.all([
        api.trimestres.list().then((r) => r.data),
        api.diasNoHabiles.list().then((r) => r.data),
      ]);
      setTrimestres(tri);
      setDiasNoHabiles(dias);
    },
  };
}
// hooks/useAcumuladoSeccion.ts
"use client";
import { useEffect, useState } from "react";
import { api } from "@/services/api";
import type { AsistenciaAcumuladoDTO } from "@/types/api-generated";

export function useAcumuladoSeccion(seccionId: number) {
  const [loading, setLoading] = useState(true);
  const [data, setData] = useState<AsistenciaAcumuladoDTO | null>(null);

  useEffect(() => {
    const hoy = new Date().toISOString().slice(0, 10);
    (async () => {
      try {
        const res = await api.asistencias.acumuladoSeccion(
          seccionId,
          "1970-01-01", // desde muy atrás
          hoy,
        );
        setData(res.data);
      } finally {
        setLoading(false);
      }
    })();
  }, [seccionId]);

  const porcentaje = data
    ? Math.round(
        (data.presentes / Math.max(1, data.presentes + data.ausentes)) * 100,
      )
    : 0;

  return { loading, data, porcentaje };
}
import { useState, useEffect, useRef, useCallback } from "react";
import { Client, StompSubscription } from "@stomp/stompjs";
import SockJS from "sockjs-client";
import type { ChatMessageDTO } from "@/types/api-generated";
import { useAuth } from "./useAuth";
import { api } from "@/services/api";

const normalizeMessage = (msg: any): ChatMessageDTO => ({
  id: msg.id,
  emisorId: msg.emisorId ?? msg.emisor ?? 0,
  receptorId: msg.receptorId ?? msg.receptor ?? 0,
  contenido: msg.contenido,
  fechaEnvio: msg.fechaEnvio ?? new Date().toISOString(),
  leido: msg.leido ?? false,
});

export type ConnectionStatus = "connecting" | "connected" | "disconnected";

export default function useChatSocket() {
  const [messages, setMessages] = useState<ChatMessageDTO[]>([]);
  const [connected, setConnected] = useState(false);
  const [connectionStatus, setConnectionStatus] =
    useState<ConnectionStatus>("connecting");
  const { user } = useAuth();

  const client = useRef<Client | null>(null);
  const subscriptions = useRef<StompSubscription[]>([]);

  // 🔹 Conectar WebSocket
  const connect = useCallback(() => {
    if (client.current?.connected) return;

    setConnectionStatus("connecting");
    console.log("🔌 Intentando conectar WebSocket...");

    const socket = new SockJS("http://localhost:8080/ws"); // Asegúrate que coincida con tu backend
    const stompClient = new Client({
      webSocketFactory: () => socket,
      reconnectDelay: 1000,
      debug: (str) => console.log("STOMP:", str),
    });

    stompClient.onConnect = (frame) => {
      console.log("✅ WebSocket conectado. Frame:", frame);
      console.log("🛎 Suscribiéndome a /user/queue/messages");
      setConnected(true);
      setConnectionStatus("connected");

      // Suscripción a mensajes
      subscriptions.current.push(
        stompClient.subscribe("/user/queue/messages", (message) => {
          if (!message.body) return;
          const msg = normalizeMessage(JSON.parse(message.body));
          console.log("📥 Mensaje recibido del backend:", msg);

          setMessages((prev) => {
            // Buscar mensaje optimista para reemplazar
            const idx = prev.findIndex(
              (m) =>
                (m?.id ?? 0) < 0 &&
                m.emisorId === msg.emisorId &&
                m.receptorId === msg.receptorId &&
                m.contenido === msg.contenido,
            );

            if (idx >= 0) {
              // Reemplaza el optimista por el real
              const newMessages = [...prev];
              newMessages[idx] = msg;
              return newMessages;
            }

            // Si no es optimista, agregar normalmente
            return [...prev, msg];
          });
        }),
      );

      // Suscripción a los ACKs del emisor
      subscriptions.current.push(
        stompClient.subscribe("/user/queue/ack", (msg) => {
          if (!msg.body) return;
          console.log("🔔 ACK recibido:", msg.body);
          const ackMessage: ChatMessageDTO = JSON.parse(msg.body);
          // Aquí actualizas tu array de mensajes reemplazando
          // el optimista (id < 0) por el que vino del servidor:
          setMessages((prev) => {
            const idx = prev.findIndex(
              (m) =>
                m.id < 0 &&
                m.receptorId === ackMessage.receptorId &&
                m.contenido === ackMessage.contenido,
            );
            if (idx === -1) return prev;
            const updated = [...prev];
            updated[idx] = ackMessage;
            return updated;
          });
        }),
      );

      // Suscripción a errores
      subscriptions.current.push(
        stompClient.subscribe("/user/queue/errors", (message) => {
          console.error("⚠️ Error desde el servidor:", message.body);
        }),
      );
    };

    stompClient.onStompError = (frame) => {
      console.error("STOMP Error:", frame);
    };

    stompClient.onWebSocketClose = () => {
      console.warn("❌ WebSocket desconectado");
      setConnected(false);
      setConnectionStatus("disconnected");
    };

    stompClient.activate();
    client.current = stompClient;
  }, []);

  // 🔹 Reconectar manual
  const reconnect = () => {
    disconnect();
    connect();
  };

  // 🔹 Desconectar limpiamente
  const disconnect = () => {
    subscriptions.current.forEach((sub) => sub.unsubscribe());
    subscriptions.current = [];
    client.current?.deactivate();
    client.current = null;
    setConnected(false);
    setConnectionStatus("disconnected");
  };

  // 🔹 Enviar mensaje

  const sendMessage = (receptorId: number, contenido: string) => {
    if (!client.current || !connected) {
      console.warn("⚠️ No se pudo enviar, WebSocket no conectado");
      return false;
    }

    // 1) Armar el mensaje optimista
    const optimisticMsg: ChatMessageDTO = {
      id: -Date.now(),
      emisorId: user?.id ?? 0,
      receptorId,
      contenido,
      fechaEnvio: new Date().toISOString(),
      leido: false,
    };

    // 2) Insertarlo inmediatamente en el estado
    setMessages((prev) => [...prev, optimisticMsg]);

    // 3) Publicar por STOMP
    const payload = { receptorId, contenido };
    console.log("📤 Enviando mensaje:", payload);
    client.current.publish({
      destination: "/app/chat.send",
      body: JSON.stringify(payload),
    });

    return true;
  };

  // 🔹 Marcar mensajes como leídos
  const markRead = async (otherUserId: number) => {
    try {
      console.log("📡 Marcando mensajes como leídos de usuario:", otherUserId);
      await fetch(`http://localhost:8080/api/chat/mark-read/${otherUserId}`, {
        method: "POST",
        credentials: "include",
      });

      setMessages((prev) =>
        prev.map((msg) =>
          msg.emisorId === otherUserId ? { ...msg, leido: true } : msg,
        ),
      );
    } catch (err) {
      console.error("Error al marcar mensajes como leídos:", err);
    }
  };

  // 🔹 Cargar historial desde la API
  const loadHistory = async (otherUserId: number) => {
    try {
      console.log("📡 Cargando historial de usuario:", otherUserId);
      const { data } = await api.chat.history(otherUserId);
      setMessages(data.map(normalizeMessage));
    } catch (err) {
      console.error("Error al cargar historial:", err);
      setMessages([]); // Evitar que queden mensajes viejos si falla
    }
  };
  // 🔹 Conectar al montar
  useEffect(() => {
    connect();
    return () => disconnect();
  }, [connect]);

  return {
    messages,
    sendMessage,
    connected,
    connectionStatus,
    reconnect,
    markRead,
    loadHistory,
  };
}

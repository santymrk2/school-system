public interface MensajeRepository extends JpaRepository<Mensaje, Long> {    // Obtener conversación entre dos usuarios ordenada por fecha    @Query("""        SELECT m FROM Mensaje m         WHERE (m.emisor.id = :userId AND m.receptor.id = :otherUserId)            OR (m.emisor.id = :otherUserId AND m.receptor.id = :userId)        ORDER BY m.fechaEnvio ASC        """)    List<Mensaje> findConversation(@Param("userId") Long userId, @Param("otherUserId") Long otherUserId);    // Marcar mensajes como leídos    @Modifying    @Query("""        UPDATE Mensaje m         SET m.leido = true         WHERE m.emisor.id = :otherUserId           AND m.receptor.id = :userId           AND m.leido = false        """)    void markAsRead(@Param("userId") Long userId, @Param("otherUserId") Long otherUserId);    // Obtener conteo de mensajes no leídos por emisor    @Query("""        SELECT m.emisor.id, COUNT(m)         FROM Mensaje m         WHERE m.receptor.id = :userId           AND m.leido = false         GROUP BY m.emisor.id        """)    List<Object[]> getUnreadCounts(@Param("userId") Long userId);    // Obtener usuarios con los que se ha tenido conversación    @Query("""        SELECT DISTINCT         CASE             WHEN m.emisor.id = :userId THEN m.receptor.id             ELSE m.emisor.id         END        FROM Mensaje m         WHERE m.emisor.id = :userId OR m.receptor.id = :userId        """)    List<Long> getActiveChatUserIds(@Param("userId") Long userId);    // Obtener contactos de un usuario (redundante con el anterior)    @Query("""        SELECT DISTINCT         CASE             WHEN m.emisor.id = :userId THEN m.receptor.id             ELSE m.emisor.id         END        FROM Mensaje m         WHERE m.emisor.id = :userId OR m.receptor.id = :userId        """)    List<Long> getUserContacts(@Param("userId") Long userId);    // Obtener último mensaje entre dos usuarios    @Query("""        SELECT m FROM Mensaje m         WHERE (m.emisor.id = :userId AND m.receptor.id = :otherUserId)            OR (m.emisor.id = :otherUserId AND m.receptor.id = :userId)        ORDER BY m.fechaEnvio DESC        """)    List<Mensaje> findLastMessage(@Param("userId") Long userId, @Param("otherUserId") Long otherUserId, Pageable pageable);    // Obtener mensajes no leídos de una conversación específica    @Query("""        SELECT m FROM Mensaje m         WHERE m.emisor.id = :otherUserId           AND m.receptor.id = :userId           AND m.leido = false        ORDER BY m.fechaEnvio ASC        """)    List<Mensaje> findUnreadMessages(@Param("userId") Long userId, @Param("otherUserId") Long otherUserId);    // Verificar si hay mensajes no leídos entre dos usuarios    @Query("""        SELECT COUNT(m) > 0         FROM Mensaje m         WHERE m.emisor.id = :otherUserId           AND m.receptor.id = :userId           AND m.leido = false        """)    boolean hasUnreadMessagesFrom(@Param("userId") Long userId, @Param("otherUserId") Long otherUserId);    // Obtener estadísticas de mensajes    @Query("""        SELECT             COUNT(m),            SUM(CASE WHEN m.leido = false AND m.receptor.id = :userId THEN 1 ELSE 0 END),            MAX(m.fechaEnvio)        FROM Mensaje m         WHERE m.emisor.id = :userId OR m.receptor.id = :userId        """)    Object[] getMessageStats(@Param("userId") Long userId);}public interface LicenciaRepository extends JpaRepository<Licencia, Long> {    boolean existsByPersonalId(Long id);}public interface PersonalRepository extends JpaRepository<Personal, Long> {    boolean existsByUsuarioId(Long id);    Optional<Personal> findByUsuario(Usuario usuario);    boolean existsByUsuario(Usuario u);}public interface AspiranteRepository extends JpaRepository<Aspirante, Long> {    boolean existsByUsuarioId(Long id);    boolean existsByDni(String dni);}public interface AspiranteFamiliarRepository extends JpaRepository<AspiranteFamiliar, Long> {    boolean existsByAspiranteId(Long id);    boolean existsByFamiliarId(Long id);}public interface AsistenciaDiaRepository extends JpaRepository<AsistenciaDia, Long> {    boolean existsBySeccionId(Long id);}public interface AlumnoRepository extends JpaRepository<Alumno, Long> {    boolean existsByUsuarioId(Long id);}public interface RegistroAsistenciaRepository extends JpaRepository<RegistroAsistencia, Long> {}public interface ComunicadoRepository extends JpaRepository<Comunicado, Long> {}public interface PagoCuotaRepository extends JpaRepository<PagoCuota, Long> {}public interface AsignacionDocenteRepository extends JpaRepository<AsignacionDocente, Long> {    boolean existsBySeccionId(Long id);    boolean existsByDocenteId(Long id);    boolean existsByMateriaId(Long id);}public interface ActaAccidenteRepository extends JpaRepository<ActaAccidente, Long> {}public interface AsistenciaPersonalRepository extends JpaRepository<edu.ecep.base_app.domain.AsistenciaPersonal, Long> {    boolean existsByPersonalId(Long id);}public interface CalificacionRepository extends JpaRepository<Calificacion, Long> {}public interface EvaluacionRepository extends JpaRepository<Evaluacion, Long> {    boolean existsBySeccionId(Long id);    boolean existsByMateriaId(Long id);}public interface CuotaRepository extends JpaRepository<Cuota, Long> {    boolean existsBySeccionId(Long id);}public interface SolicitudAdmisionRepository extends JpaRepository<SolicitudAdmision, Long> {    boolean existsByAspiranteId(Long id);}public interface UsuarioRepository extends JpaRepository<Usuario, Long> {    Optional<Usuario> findByEmail(String email);    Boolean existsByEmail(String email);    /*    @Query("""        SELECT             u.id as idUsuario,            u.email as email,            u.roles as roles,            p.id as idPersona,            CONCAT(p.nombre, ' ', p.apellido) as nombreCompleto,            p.dni as dni,            TYPE(p).name as tipoPersona        FROM Usuario u        LEFT JOIN u.persona p        WHERE u.id <> :currentId          AND (              LOWER(u.email) LIKE LOWER(CONCAT('%', :q, '%'))           OR LOWER(p.nombre) LIKE LOWER(CONCAT('%', :q, '%'))           OR LOWER(p.apellido) LIKE LOWER(CONCAT('%', :q, '%'))           OR LOWER(p.dni) LIKE LOWER(CONCAT('%', :q, '%'))          )        ORDER BY u.email    """)    List<UsuarioBusquedaProjection> buscarUsuariosConTipo(@Param("q") String q,                                                          @Param("currentId") Long currentId);    @Query("""SELECT DISTINCT    u.id AS id,    u.email AS email,    u.roles AS roles,    p.id AS personaId,    CONCAT(p.nombre, ' ', p.apellido) AS nombreCompleto,    p.dni AS dni,    TYPE(p).name AS tipoPersonaFROM Usuario uLEFT JOIN u.persona pWHERE u.email = :email""")    List<UsuarioBusquedaProjection> buscarUsuarioBusquedaPorEmail(@Param("email") String email);*/}public interface FormacionAcademicaRepository extends JpaRepository<FormacionAcademica, Long> {}public interface FamiliarRepository extends JpaRepository<Familiar, Long> {    List<Familiar> findByNombreContainingIgnoreCaseOrApellidoContainingIgnoreCase(String n, String a);    boolean existsByUsuarioId(Long id);}public interface MatriculaRepository extends JpaRepository<Matricula, Long> {    boolean existsBySeccionId(Long id);    boolean existsByAlumnoId(Long id);}package edu.ecep.base_app.repos;public interface ReciboSueldoRepository extends JpaRepository<ReciboSueldo, Long> {    boolean existsByPersonalId(Long id);}public interface SeccionRepository extends JpaRepository<Seccion, Long> {}public interface InformeInicialRepository extends JpaRepository<InformeInicial, Long> {}public interface AlumnoFamiliarRepository extends JpaRepository<AlumnoFamiliar, Long> {    boolean existsByFamiliarId(Long id);    boolean existsByAlumnoId(Long id);}public interface MateriaRepository extends JpaRepository<Materia, Long> {}public interface DiaNoHabilRepository extends JpaRepository<DiaNoHabil, Long> {}
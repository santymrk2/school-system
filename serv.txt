package edu.ecep.base_app.service;



@Service
public class AspiranteFamiliarService {
    private final AspiranteFamiliarRepository repository;
    private final AspiranteFamiliarMapper mapper;

    public AspiranteFamiliarService(AspiranteFamiliarRepository repository, AspiranteFamiliarMapper mapper) {
        this.repository = repository;
        this.mapper = mapper;
    }

    public List<AspiranteFamiliarDTO> findAll() {
        return repository.findAll(Sort.by("id")).stream().map(mapper::toDto).toList();
    }

    public AspiranteFamiliarDTO get(Long id) {
        return repository.findById(id).map(mapper::toDto).orElseThrow(NotFoundException::new);
    }

    public Long create(AspiranteFamiliarDTO dto) {
        return repository.save(mapper.toEntity(dto)).getId();
    }

    public void update(Long id, AspiranteFamiliarDTO dto) {
        AspiranteFamiliar entity = repository.findById(id).orElseThrow(NotFoundException::new);
        mapper.updateEntityFromDto(dto, entity);
        repository.save(entity);
    }

    public void delete(Long id) {
        repository.deleteById(id);
    }
}
package edu.ecep.base_app.service;



@Service
@RequiredArgsConstructor
public class JornadaAsistenciaService {

    private final JornadaAsistenciaRepository repo;
    private final JornadaAsistenciaMapper mapper;
    private final TrimestreRepository trimRepo;

    public List<JornadaAsistenciaDTO> findAll() {
        return repo.findAll(Sort.by("fecha").descending())
                .stream().map(mapper::toDto).toList();
    }
    @Transactional(readOnly = true)
    public Optional<JornadaAsistenciaDTO> findBySeccionAndFecha(Long seccionId, LocalDate fecha) {
        return repo.findBySeccionIdAndFecha(seccionId, fecha).map(mapper::toDto);
    }

    public Long abrir(JornadaAsistenciaCreateDTO dto) {
        // no duplicar jornadas por sección+fecha
        if (repo.existsBySeccionIdAndFecha(dto.getSeccionId(), dto.getFecha())) {
            throw new IllegalArgumentException("Ya existe una jornada para esa sección y fecha");
        }
        // validar trimestre y que no esté cerrado
        Trimestre tri = trimRepo.findById(dto.getTrimestreId())
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Trimestre no encontrado"));
        if (Boolean.TRUE.equals(tri.isCerrado())) {
            throw new IllegalArgumentException("El trimestre está cerrado");
        }
        return repo.save(mapper.toEntity(dto)).getId();
    }


    @Transactional(readOnly = true)
    public JornadaAsistenciaDTO get(Long id) {
        var j = repo.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Jornada " + id + " no encontrada"));
        return mapper.toDto(j);
    }
    public List<JornadaAsistenciaDTO> findBySeccion(Long seccionId) {
        return repo.findBySeccionId(seccionId).stream().map(mapper::toDto).toList();
    }

    public List<JornadaAsistenciaDTO> findBySeccionBetween(Long seccionId, LocalDate from, LocalDate to) {
        return repo.findBySeccionIdAndFechaBetween(seccionId, from, to)
                .stream().map(mapper::toDto).toList();
    }

    public List<JornadaAsistenciaDTO> findByTrimestre(Long trimestreId) {
        return repo.findByTrimestreId(trimestreId).stream().map(mapper::toDto).toList();
    }
}
package edu.ecep.base_app.service;



@Service
@RequiredArgsConstructor
public class AsignacionDocenteSeccionService {
    private final AsignacionDocenteSeccionRepository repo; private final AsignacionDocenteSeccionMapper mapper;
    public List<AsignacionDocenteSeccionDTO> findAll(){ return repo.findAll().stream().map(mapper::toDto).toList(); }
    public Long create(AsignacionDocenteSeccionCreateDTO dto){
        LocalDate hasta = dto.getVigenciaHasta()==null? LocalDate.of(9999,12,31): dto.getVigenciaHasta();
        if(dto.getRol()== RolSeccion.MAESTRO_TITULAR && repo.hasTitularOverlap(dto.getSeccionId(), dto.getVigenciaDesde(), hasta, null))
            throw new IllegalArgumentException("Ya hay un titular vigente en ese rango");
        return repo.save(mapper.toEntity(dto)).getId();
    }
}
package edu.ecep.base_app.service;



@Service
public class JwtService {

    @Value("${jwt.secret}")
    private String secret;

    @Value("${jwt.expiration}")
    private Long expiration;

    // Generar token
    public String generateToken(Usuario usuario) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("roles", usuario.getRoles());
        claims.put("email", usuario.getEmail());

        return Jwts.builder()
                .setClaims(claims)
                .setSubject(usuario.getEmail())
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + expiration))
                .signWith(SignatureAlgorithm.HS256, secret)
                .compact();
    }

    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    private Claims extractAllClaims(String token) {
        return Jwts.parser()
                .setSigningKey(secret)
                .parseClaimsJws(token)
                .getBody();
    }

    public boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    public boolean validateToken(String token) {
        try {
            return !isTokenExpired(token);
        } catch (Exception e) {
            return false;
        }
    }

    public Optional<String> safeExtractUsername(String token) {
        try {
            return Optional.ofNullable(extractUsername(token));
        } catch (Exception e) {
            return Optional.empty();
        }
    }
}
package edu.ecep.base_app.service;




// src/main/java/.../ActaAccidenteService.java
@Service @RequiredArgsConstructor
public class ActaAccidenteService {
    private final ActaAccidenteRepository repo;
    private final ActaAccidenteMapper mapper;

    public List<ActaAccidenteDTO> findAll(){
        return repo.findAll(Sort.by("fechaSuceso").descending())
                .stream().map(mapper::toDto).toList();
    }

    public Long create(ActaAccidenteCreateDTO dto){
        if (ChronoUnit.DAYS.between(dto.getFechaSuceso(), LocalDate.now()) > 2)
            throw new IllegalArgumentException("Fuera de ventana de edición");
        return repo.save(mapper.toEntity(dto)).getId();
    }

    public void update(Long id, ActaAccidenteUpdateDTO dto){
        ActaAccidente acta = repo.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Acta no encontrada: " + id));

        long diffOriginal = ChronoUnit.DAYS.between(acta.getFechaSuceso(), LocalDate.now());
        long diffNueva    = ChronoUnit.DAYS.between(dto.fechaSuceso(), LocalDate.now());
        if (diffOriginal > 2 || diffNueva > 2) {
            throw new IllegalArgumentException("Fuera de ventana de edición");
        }

        mapper.applyUpdate(acta, dto);
        repo.save(acta);
    }


    public void delete(Long id){
        ActaAccidente acta = repo.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Acta no encontrada: " + id));

        // (Con seguridad: sólo Dirección. @SQLDelete hará soft delete.)
        repo.delete(acta);
    }
}
package edu.ecep.base_app.service;




@Service @RequiredArgsConstructor
public class MatriculaService {
    private final MatriculaRepository repo; private final MatriculaMapper mapper;
    public List<MatriculaDTO> findAll(){ return repo.findAll().stream().map(mapper::toDto).toList(); }
    public Long create(MatriculaCreateDTO dto){
        if(repo.existsByAlumnoIdAndPeriodoEscolarId(dto.getAlumnoId(), dto.getPeriodoEscolarId()))
            throw new IllegalArgumentException("El alumno ya tiene matrícula en ese periodo");
        return repo.save(mapper.toEntity(dto)).getId();
    }
}
package edu.ecep.base_app.service;



@Service
public class AsistenciaEmpleadoService {

    private final AsistenciaEmpleadoRepository asistenciaDiaRepository;
    private final AsistenciaEmpleadoMapper asistenciaDiaMapper;

    public AsistenciaEmpleadoService(AsistenciaEmpleadoRepository asistenciaDiaRepository,
                                     AsistenciaEmpleadoMapper asistenciaDiaMapper) {
        this.asistenciaDiaRepository = asistenciaDiaRepository;
        this.asistenciaDiaMapper = asistenciaDiaMapper;
    }

    public List<AsistenciaEmpleadoDTO> findAll() {
        return asistenciaDiaRepository.findAll(Sort.by("id")).stream()
                .map(asistenciaDiaMapper::toDto)
                .toList();
    }

    public AsistenciaEmpleadoDTO get(Long id) {
        return asistenciaDiaRepository.findById(id)
                .map(asistenciaDiaMapper::toDto)
                .orElseThrow(NotFoundException::new);
    }

    public Long create(AsistenciaEmpleadoDTO dto) {
        AsistenciaEmpleados entity = asistenciaDiaMapper.toEntity(dto);
        return asistenciaDiaRepository.save(entity).getId();
    }

    public void update(Long id, AsistenciaEmpleadoDTO dto) {
        AsistenciaEmpleados existing = asistenciaDiaRepository.findById(id)
                .orElseThrow(NotFoundException::new);
        asistenciaDiaMapper.updateEntityFromDto(dto, existing);
        asistenciaDiaRepository.save(existing);
    }

    public void delete(Long id) {
        asistenciaDiaRepository.deleteById(id);
    }
}package edu.ecep.base_app.service;



@Service
public class DiaNoHabilService {
    private final DiaNoHabilRepository repository;
    private final DiaNoHabilMapper mapper;

    public DiaNoHabilService(DiaNoHabilRepository repository, DiaNoHabilMapper mapper) {
        this.repository = repository;
        this.mapper = mapper;
    }

    public List<DiaNoHabilDTO> findAll() {
        return repository.findAll(Sort.by("id")).stream().map(mapper::toDto).toList();
    }

    public DiaNoHabilDTO get(Long id) {
        return repository.findById(id).map(mapper::toDto).orElseThrow(NotFoundException::new);
    }

    public Long create(DiaNoHabilDTO dto) {
        return repository.save(mapper.toEntity(dto)).getId();
    }

    public void update(Long id, DiaNoHabilDTO dto) {
        DiaNoHabil entity = repository.findById(id).orElseThrow(NotFoundException::new);
        mapper.update(entity, dto);   // <-- antes: updateEntityFromDto(dto, entity)
        repository.save(entity);
    }


    public void delete(Long id) {
        repository.deleteById(id);
    }
}
package edu.ecep.base_app.service;




@Service @RequiredArgsConstructor
public class ComunicadoService {
    private final ComunicadoRepository repo; private final ComunicadoMapper mapper;
    public List<ComunicadoDTO> findAll(){ return repo.findAll(Sort.by("id")).stream().map(mapper::toDto).toList(); }
    public Long create(ComunicadoCreateDTO dto){
        // Validaciones condicionales por alcance
        if(dto.getAlcance()==AlcanceComunicado.POR_SECCION && dto.getSeccionId()==null) throw new IllegalArgumentException("Sección requerida");
        if(dto.getAlcance()== AlcanceComunicado.POR_NIVEL && dto.getNivel()==null) throw new IllegalArgumentException("Nivel requerido");
        return repo.save(mapper.toEntity(dto)).getId();
    }
}
package edu.ecep.base_app.service;



@Service @RequiredArgsConstructor
public class CuotaService {
    private final CuotaRepository repo; private final CuotaMapper mapper;
    public List<CuotaDTO> findAll(){ return repo.findAll(Sort.by("anio","mes")).stream().map(mapper::toDto).toList(); }
    public Long create(CuotaCreateDTO dto){
        // reglas de unicidad por concepto
        if(dto.getConcepto()== ConceptoCuota.MENSUALIDAD && repo.existsByMatriculaIdAndAnioAndMesAndConcepto(dto.getMatriculaId(), dto.getAnio(), dto.getMes(), dto.getConcepto()))
            throw new IllegalArgumentException("Mensualidad duplicada");
        if(dto.getConcepto()==ConceptoCuota.MATRICULA && repo.existsByMatriculaIdAndAnioAndConcepto(dto.getMatriculaId(), dto.getAnio(), dto.getConcepto()))
            throw new IllegalArgumentException("Matrícula duplicada");
        return repo.save(mapper.toEntity(dto)).getId();
    }
}package edu.ecep.base_app.service;



@Service
@RequiredArgsConstructor
@Transactional
public class ChatService {

    private final MensajeRepository mensajeRepository;
    private final UsuarioRepository usuarioRepository;
    private final RedisTemplate<String, Object> redisTemplate;

    private static final String CHANNEL = "chat";
    private static final String ONLINE_USERS_KEY = "chat:online_users";
    private static final String USER_LAST_SEEN_KEY = "chat:last_seen:";

    /**
     * Guarda el mensaje en la BD y lo publica por Redis para su diseminación.
     */
    public Mensaje saveAndSend(SendMessageRequest request, Usuario emisor) {
        // Validaciones
        if (request.getContenido() == null || request.getContenido().trim().isEmpty()) {
            throw new IllegalArgumentException("El mensaje no puede estar vacío");
        }
        if (request.getContenido().length() > 1000) {
            throw new IllegalArgumentException("El mensaje es demasiado largo");
        }

        // Creación de entidad
        Mensaje mensaje = new Mensaje();
        mensaje.setEmisor(emisor);
        mensaje.setReceptor(usuarioRepository.findById(request.getReceptorId())
                .orElseThrow(() -> new IllegalArgumentException("Usuario receptor no encontrado")));
        mensaje.setContenido(request.getContenido().trim());
        mensaje.setFechaEnvio(OffsetDateTime.now());
        mensaje.setLeido(false);

        // Persistir en BD
        Mensaje saved = mensajeRepository.save(mensaje);

        // Convertir a DTO y publicar en Redis
        ChatMessageDTO dto = toDto(saved);
        redisTemplate.convertAndSend(CHANNEL, dto);

        return saved;
    }

    public List<ChatMessageDTO> getHistory(Long userId, Long otherUserId) {
        return mensajeRepository
                .findConversation(userId, otherUserId)
                .stream()
                .map(this::toDto)
                .sorted(Comparator.comparing(ChatMessageDTO::getFechaEnvio))
                .collect(Collectors.toList());
    }

    public void markRead(Long userId, Long otherUserId) {
        mensajeRepository.markAsRead(userId, otherUserId);
        redisTemplate.opsForValue().set(
                "chat:last_read:" + userId + ":" + otherUserId,
                System.currentTimeMillis()
        );
    }

    public Map<Long, Long> getUnreadCounts(Long userId) {
        return mensajeRepository.getUnreadCounts(userId)
                .stream()
                .collect(Collectors.toMap(
                        row -> (Long) row[0],
                        row -> (Long) row[1]
                ));
    }

    public List<Usuario> getActiveChatUsers(Long userId) {
        List<Long> activeUserIds = mensajeRepository.getActiveChatUserIds(userId);
        return usuarioRepository.findAllById(activeUserIds);
    }

    public void setUserOnline(Long userId) {
        redisTemplate.opsForSet().add(ONLINE_USERS_KEY, userId.toString());
        redisTemplate.opsForValue().set(USER_LAST_SEEN_KEY + userId, System.currentTimeMillis());
    }

    public void setUserOffline(Long userId) {
        redisTemplate.opsForSet().remove(ONLINE_USERS_KEY, userId.toString());
        redisTemplate.opsForValue().set(USER_LAST_SEEN_KEY + userId, System.currentTimeMillis());
    }

    public Map<Long, Boolean> getOnlineStatus(List<Long> userIds) {
        return userIds.stream()
                .collect(Collectors.toMap(
                        id -> id,
                        id -> redisTemplate.opsForSet().isMember(ONLINE_USERS_KEY, id.toString())
                ));
    }

    public List<Long> getUserContacts(Long userId) {
        return mensajeRepository.getUserContacts(userId);
    }

    /** Convierte la entidad Mensaje a ChatMessageDTO */
    public ChatMessageDTO toDto(Mensaje mensaje) {
        ChatMessageDTO dto = new ChatMessageDTO();
        dto.setId(mensaje.getId());
        dto.setEmisorId(mensaje.getEmisor().getId());
        dto.setReceptorId(mensaje.getReceptor().getId());
        dto.setContenido(mensaje.getContenido());
        dto.setFechaEnvio(mensaje.getFechaEnvio());
        dto.setLeido(mensaje.getLeido());
        return dto;
    }
}
package edu.ecep.base_app.service;







@Service @RequiredArgsConstructor
public class AlumnoService {

    private final AlumnoRepository alumnoRepository;
    private final MatriculaRepository matriculaRepository;
    private final AlumnoFamiliarRepository alumnoFamiliarRepository;
    private final AlumnoMapper alumnoMapper;
    private final PersonaRepository personaRepository;

    public List<AlumnoDTO> findAll() {
        return alumnoRepository.findAll(Sort.by("id"))
                .stream().map(alumnoMapper::toDto).toList();
    }

    public AlumnoDTO get(Long id) {
        return alumnoRepository.findById(id)
                .map(alumnoMapper::toDto)
                .orElseThrow(() -> new NotFoundException("Alumno no encontrado"));
    }

    @Transactional
    public Long create(AlumnoDTO dto) {
        // 1) Validar persona existente
        var persona = personaRepository.findById(dto.getPersonaId())
                .orElseThrow(() -> new NotFoundException("Persona no encontrada"));

        // 2) Evitar duplicado: una persona no puede ser Alumno dos veces
        if (alumnoRepository.existsByPersonaId(persona.getId())) {
            throw new IllegalArgumentException("La persona ya tiene rol Alumno");
        }

        // 3) Mapear y setear la relación de forma explícita
        var entity = alumnoMapper.toEntity(dto);
        entity.setPersona(persona);

        return alumnoRepository.save(entity).getId();
    }

    @Transactional
    public void update(Long id, AlumnoDTO dto) {
        var existing = alumnoRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Alumno no encontrado"));

        // Si cambian la persona vinculada, validar existencia + no duplicar
        if (dto.getPersonaId() != null &&
                (existing.getPersona() == null ||
                        !dto.getPersonaId().equals(existing.getPersona().getId()))) {

            var persona = personaRepository.findById(dto.getPersonaId())
                    .orElseThrow(() -> new NotFoundException("Persona no encontrada"));

            // Si esa persona ya es alumno y no es el mismo registro, rechazar
            if (alumnoRepository.existsByPersonaId(persona.getId())) {
                throw new IllegalArgumentException("La persona ya tiene rol Alumno");
            }
            existing.setPersona(persona);
        }

        // actualizar otros campos del alumno
        alumnoMapper.update(existing, dto);
        alumnoRepository.save(existing);
    }

    @Transactional
    public void delete(Long id) {
        ReferencedWarning warning = getReferencedWarning(id);
        if (warning != null) throw new ReferencedException(warning);
        if (!alumnoRepository.existsById(id)) {
            throw new NotFoundException("Alumno no encontrado: " + id);
        }
        alumnoRepository.deleteById(id);
    }

    public ReferencedWarning getReferencedWarning(Long id) {
        // ⚠️ requiere repo: boolean existsByAlumnoId(Long alumnoId)
        if (matriculaRepository.existsByAlumnoId(id)) {
            ReferencedWarning w = new ReferencedWarning("alumno.referenciado.matriculas");
            w.addParam(id);
            return w;
        }
        // ⚠️ requiere repo: boolean existsByAlumnoId(Long alumnoId)
        if (alumnoFamiliarRepository.existsByAlumnoId(id)) {
            ReferencedWarning w = new ReferencedWarning("alumno.referenciado.familiares");
            w.addParam(id);
            return w;
        }
        return null;
    }
}
package edu.ecep.base_app.service;



@Service @RequiredArgsConstructor
public class SolicitudBajaAlumnoService {
    private final SolicitudBajaAlumnoRepository repo; private final SolicitudBajaAlumnoMapper mapper;
    public List<SolicitudBajaAlumnoDTO> findAll(){ return repo.findAll().stream().map(mapper::toDto).toList(); }
    public Long create(SolicitudBajaAlumnoCreateDTO dto){ return repo.save(mapper.toEntity(dto)).getId(); }
}
package edu.ecep.base_app.service;




@Service
public class SolicitudAdmisionService {
    private final SolicitudAdmisionRepository repository;
    private final SolicitudAdmisionMapper mapper;

    public SolicitudAdmisionService(SolicitudAdmisionRepository repository, SolicitudAdmisionMapper mapper) {
        this.repository = repository;
        this.mapper = mapper;
    }

    public List<SolicitudAdmisionDTO> findAll() {
        return repository.findAll(Sort.by("id")).stream().map(mapper::toDto).toList();
    }

    public SolicitudAdmisionDTO get(Long id) {
        return repository.findById(id).map(mapper::toDto).orElseThrow(NotFoundException::new);
    }

    public Long create(SolicitudAdmisionDTO dto) {
        return repository.save(mapper.toEntity(dto)).getId();
    }

    public void update(Long id, SolicitudAdmisionDTO dto) {
        SolicitudAdmision entity = repository.findById(id).orElseThrow(NotFoundException::new);
        mapper.updateEntityFromDto(dto, entity);
        repository.save(entity);
    }

    public void delete(Long id) {
        repository.deleteById(id);
    }
}
package edu.ecep.base_app.service;



@Service
public class FormacionAcademicaService {
    private final FormacionAcademicaRepository repository;
    private final FormacionAcademicaMapper mapper;

    public FormacionAcademicaService(FormacionAcademicaRepository repository, FormacionAcademicaMapper mapper) {
        this.repository = repository;
        this.mapper = mapper;
    }

    public List<FormacionAcademicaDTO> findAll() {
        return repository.findAll(Sort.by("id")).stream().map(mapper::toDto).toList();
    }

    public FormacionAcademicaDTO get(Long id) {
        return repository.findById(id).map(mapper::toDto).orElseThrow(NotFoundException::new);
    }

    public Long create(FormacionAcademicaDTO dto) {
        return repository.save(mapper.toEntity(dto)).getId();
    }

    public void update(Long id, FormacionAcademicaDTO dto) {
        FormacionAcademica entity = repository.findById(id).orElseThrow(NotFoundException::new);
        mapper.updateEntityFromDto(dto, entity);
        repository.save(entity);
    }

    public void delete(Long id) {
        repository.deleteById(id);
    }
}
package edu.ecep.base_app.service;



@Service
@RequiredArgsConstructor
public class EvaluacionService {
    private final EvaluacionRepository repo; private final EvaluacionMapper mapper; private final MatriculaSeccionHistorialRepository histRepo; private final TrimestreRepository trimRepo;
    public List<EvaluacionDTO> findAll(){ return repo.findAll(Sort.by("fecha").descending()).stream().map(mapper::toDto).toList(); }
    public Long create(EvaluacionCreateDTO dto){
        Trimestre tri = trimRepo.findById(dto.getTrimestreId()).orElseThrow(() -> new NotFoundException("No encontrado"));
        if(tri.isCerrado()) throw new IllegalArgumentException("Trimestre cerrado");
        return repo.save(mapper.toEntity(dto)).getId();
    }
}package edu.ecep.base_app.service;



@Service
@RequiredArgsConstructor
public class SeccionMateriaService {
    private final SeccionMateriaRepository repo; private final SeccionMateriaMapper mapper;
    public List<SeccionMateriaDTO> findAll(){ return repo.findAll().stream().map(mapper::toDto).toList(); }
    public Long create(SeccionMateriaCreateDTO dto){ if(repo.existsBySeccionIdAndMateriaId(dto.getSeccionId(), dto.getMateriaId())) throw new IllegalArgumentException("Materia ya asignada al plan de estudio"); return repo.save(mapper.toEntity(dto)).getId(); }
}package edu.ecep.base_app.service;




@Service @RequiredArgsConstructor
public class SeccionService {
    private final SeccionRepository repo; private final SeccionMapper mapper;
    public List<SeccionDTO> findAll(){ return repo.findAll(Sort.by("periodoEscolar.id","nivel","gradoSala","division")).stream().map(mapper::toDto).toList(); }
    public Long create(SeccionCreateDTO dto){
        if(repo.existsByPeriodoEscolarIdAndNivelAndGradoSalaAndDivisionAndTurno(dto.getPeriodoEscolarId(), dto.getNivel(), dto.getGradoSala(), dto.getDivision(), dto.getTurno()))
            throw new IllegalArgumentException("La sección ya existe en ese periodo");
        return repo.save(mapper.toEntity(dto)).getId();
    }
}package edu.ecep.base_app.service;


@Component
public class RedisSubscriber {
    private final SimpMessagingTemplate messagingTemplate;
    private final ObjectMapper objectMapper;

    public RedisSubscriber(SimpMessagingTemplate messagingTemplate,
                           ObjectMapper objectMapper) {
        this.messagingTemplate = messagingTemplate;
        this.objectMapper = objectMapper;
    }

    public void handleMessage(String messageJson) throws Exception {
        // 📌 Añade un log aquí para verificar que se invoque
        System.out.println("🔔 RedisSubscriber got: " + messageJson);
        ChatMessageDTO msg = objectMapper.readValue(messageJson, ChatMessageDTO.class);
        System.out.println("🔔 RedisSubscriber got: " + messageJson);
        System.out.println("🛰️ Enviando a WS /user/" + msg.getReceptorId() + "/queue/messages");
        messagingTemplate.convertAndSendToUser(
                msg.getReceptorId().toString(),
                "/queue/messages",
                msg
        );
        System.out.println("✔️ Enviado al broker STOMP");
    }
}
package edu.ecep.base_app.service;



@Service
@RequiredArgsConstructor
public class EmpleadoService {

    private final EmpleadoRepository repo;
    private final PersonaRepository personaRepository;
    private final AsignacionDocenteSeccionRepository adsRepo;
    private final AsignacionDocenteMateriaRepository admRepo;
    private final ReciboSueldoRepository reciboRepo;
    private final LicenciaRepository licenciaRepo;
    private final AsistenciaEmpleadoRepository asistenciaRepo;
    private final EmpleadoMapper mapper;

    public List<EmpleadoDTO> findAll() {
        return repo.findAll(Sort.by("id")).stream()
                .map(mapper::toDto)
                .toList();
    }

    public EmpleadoDTO get(Long id) {
        return repo.findById(id)
                .map(mapper::toDto)
                .orElseThrow(() -> new NotFoundException("Empleado no encontrado"));
    }

    @Transactional
    public EmpleadoDTO create(EmpleadoCreateDTO dto) {
        if (dto.getPersonaId() == null) {
            throw new IllegalArgumentException("Debe enviar personaId");
        }

        // 1) Persona existente
        Persona persona = personaRepository.findById(dto.getPersonaId())
                .orElseThrow(() -> new NotFoundException("Persona no encontrada"));

        // 2) Evitar duplicado: una persona no puede tener dos Empleados
        if (repo.existsByPersonaId(persona.getId())) {
            throw new IllegalArgumentException("La persona ya tiene rol Empleado");
        }

        // 3) Crear empleado (si usás @MapsId, el id del empleado será el de persona)
        Empleado p = new Empleado();
        p.setPersona(persona);
        p.setCondicionLaboral(dto.getCondicionLaboral());
        p.setCargo(dto.getCargo());
        p.setSituacionActual(dto.getSituacionActual());
        p.setFechaIngreso(dto.getFechaIngreso());
        p.setAntecedentesLaborales(dto.getAntecedentesLaborales());

        p = repo.save(p);
        return mapper.toDto(p);
    }

    @Transactional
    public EmpleadoDTO update(Long id, EmpleadoUpdateDTO dto) {
        Empleado p = repo.findById(id)
                .orElseThrow(() -> new NotFoundException("Empleado no encontrado"));

        // Con @MapsId NO permitimos cambiar la persona (cambia la PK).
        if (dto.getPersonaId() != null) {
            Long currentPersonaId = (p.getPersona() != null) ? p.getPersona().getId() : null;
            if (!dto.getPersonaId().equals(currentPersonaId)) {
                throw new IllegalArgumentException(
                        "No se puede cambiar la persona de un Empleado. " +
                                "Elimine el registro y cree uno nuevo con el personaId correcto."
                );
            }
            // Si es igual, no hacemos nada (idempotente).
        }

        // Update laboral (solo campos no nulos)
        if (dto.getCondicionLaboral() != null)  p.setCondicionLaboral(dto.getCondicionLaboral());
        if (dto.getCargo() != null)             p.setCargo(dto.getCargo());
        if (dto.getSituacionActual() != null)   p.setSituacionActual(dto.getSituacionActual());
        if (dto.getFechaIngreso() != null)      p.setFechaIngreso(dto.getFechaIngreso());
        if (dto.getAntecedentesLaborales() != null) p.setAntecedentesLaborales(dto.getAntecedentesLaborales());

        // Hibernate hace flush al salir de @Transactional
        return mapper.toDto(p);
    }

    @Transactional
    public void delete(Long id) {
        ReferencedWarning w = getReferencedWarning(id);
        if (w != null) throw new ReferencedException(w);
        if (!repo.existsById(id)) throw new NotFoundException("Empleado no encontrado: " + id);
        repo.deleteById(id);
    }

    public ReferencedWarning getReferencedWarning(Long id) {
        if (licenciaRepo.existsByEmpleadoId(id))
            return new ReferencedWarning("empleado.referenciado.licencias");
        if (reciboRepo.existsByEmpleadoId(id))
            return new ReferencedWarning("empleado.referenciado.recibos");
        if (asistenciaRepo.existsByEmpleadoId(id))
            return new ReferencedWarning("empleado.referenciado.asistencia");
        // (Opcional) validar asignaciones si tenés estos métodos:
        // if (adsRepo.existsByEmpleadoId(id) || admRepo.existsByEmpleadoId(id)) ...
        return null;
    }
}package edu.ecep.base_app.service;




@Service @RequiredArgsConstructor
public class InformeInicialService {
    private final InformeInicialRepository repo; private final InformeInicialMapper mapper; private final TrimestreRepository trimRepo;
    public List<InformeInicialDTO> findAll(){ return repo.findAll().stream().map(mapper::toDto).toList(); }
    public Long create(InformeInicialCreateDTO dto) {
        return repo.save(mapper.toEntity(dto)).getId();
    }
    public void update(Long id, InformeInicialDTO dto) {
        InformeInicial e = repo.findById(id).orElseThrow(NotFoundException::new);
        mapper.update(e, dto);
    }
}package edu.ecep.base_app.service;


@Service
public class RedisPublisher {

    private final RedisTemplate<String, Object> redisTemplate;

    public RedisPublisher(RedisTemplate<String, Object> redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    public void publish(String channel, Object message) {
        redisTemplate.convertAndSend(channel, message);
    }
}
package edu.ecep.base_app.service;



@Service @RequiredArgsConstructor
public class ReciboSueldoService {
    private final ReciboSueldoRepository repo; private final ReciboSueldoMapper mapper;
    public List<ReciboSueldoDTO> findAll(){ return repo.findAll(Sort.by("anio","mes")).stream().map(mapper::toDto).toList(); }
    public Long create(ReciboSueldoCreateDTO dto){ return repo.save(mapper.toEntity(dto)).getId(); }
}

package edu.ecep.base_app.service;



@Service
public class AuthService {

    @Autowired
    private UsuarioRepository usuarioRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Autowired
    private JwtService jwtService;

    @Autowired
    private AuthenticationManager authenticationManager;

    // LOGIN
    public AuthResponse login(String email, String password) {
        Usuario usuario = usuarioRepository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("Usuario no encontrado"));

        if (!passwordEncoder.matches(password, usuario.getPassword())) {
            throw new BadCredentialsException("Credenciales inválidas");
        }

        String token = jwtService.generateToken(usuario);
        return new AuthResponse(token, usuario.getEmail(), usuario.getUserRoles());
    }

    // REGISTER
    public AuthResponse register(Usuario request) {
        if (usuarioRepository.existsByEmail(request.getEmail())) {
            throw new RuntimeException("El email ya está registrado");
        }

        Usuario usuario = new Usuario();
        usuario.setEmail(request.getEmail());
        usuario.setPassword(passwordEncoder.encode(request.getPassword()));
        usuario.setUserRoles(Set.of(UserRole.USER)); // Rol por defecto

        usuario = usuarioRepository.save(usuario);

        String token = jwtService.generateToken(usuario);

        return new AuthResponse(token, usuario.getEmail(), usuario.getUserRoles());
    }

    // NUEVO MÉTODO: Obtener usuario actual como DTO
    public Optional<UsuarioBusquedaDTO> getCurrentUserDTO(String email) {
        return usuarioRepository.findByEmail(email)
                .map(usuario -> {
                    Persona p = usuario.getPersona();
                    return new UsuarioBusquedaDTO(
                            usuario.getId(),
                            usuario.getEmail(),
                            usuario.getUserRoles(),
                            p != null ? p.getId() : null,
                            p != null ? p.getNombre() + " " + p.getApellido() : null,
                            p != null ? p.getDni() : null,
                            p != null ? p.getClass().getSimpleName() : null
                    );
                });
    }
}
package edu.ecep.base_app.service;



@Service
public class MensajeService {

    private final MensajeRepository mensajeRepository;
    private final UsuarioRepository usuarioRepository;

    public MensajeService(final MensajeRepository mensajeRepository,
            final UsuarioRepository usuarioRepository) {
        this.mensajeRepository = mensajeRepository;
        this.usuarioRepository = usuarioRepository;
    }

    public List<MensajeDTO> findAll() {
        final List<Mensaje> mensajes = mensajeRepository.findAll(Sort.by("id"));
        return mensajes.stream()
                .map(mensaje -> mapToDTO(mensaje, new MensajeDTO()))
                .toList();
    }

    public MensajeDTO get(final Long id) {
        return mensajeRepository.findById(id)
                .map(mensaje -> mapToDTO(mensaje, new MensajeDTO()))
                .orElseThrow(NotFoundException::new);
    }

    public Long create(final MensajeDTO mensajeDTO) {
        final Mensaje mensaje = new Mensaje();
        mapToEntity(mensajeDTO, mensaje);
        return mensajeRepository.save(mensaje).getId();
    }

    public void update(final Long id, final MensajeDTO mensajeDTO) {
        final Mensaje mensaje = mensajeRepository.findById(id)
                .orElseThrow(NotFoundException::new);
        mapToEntity(mensajeDTO, mensaje);
        mensajeRepository.save(mensaje);
    }

    public void delete(final Long id) {
        mensajeRepository.deleteById(id);
    }

    private MensajeDTO mapToDTO(final Mensaje mensaje, final MensajeDTO mensajeDTO) {
        mensajeDTO.setId(mensaje.getId());
        mensajeDTO.setFechaEnvio(mensaje.getFechaEnvio());
        mensajeDTO.setAsunto(mensaje.getAsunto());
        mensajeDTO.setContenido(mensaje.getContenido());
        mensajeDTO.setLeido(mensaje.getLeido());
        mensajeDTO.setEmisor(mensaje.getEmisor() == null ? null : mensaje.getEmisor().getId());
        mensajeDTO.setReceptor(mensaje.getReceptor() == null ? null : mensaje.getReceptor().getId());
        return mensajeDTO;
    }

    private Mensaje mapToEntity(final MensajeDTO mensajeDTO, final Mensaje mensaje) {
        mensaje.setFechaEnvio(mensajeDTO.getFechaEnvio());
        mensaje.setAsunto(mensajeDTO.getAsunto());
        mensaje.setContenido(mensajeDTO.getContenido());
        mensaje.setLeido(mensajeDTO.getLeido());
        final Usuario emisor = mensajeDTO.getEmisor() == null ? null : usuarioRepository.findById(mensajeDTO.getEmisor())
                .orElseThrow(() -> new NotFoundException("emisor not found"));
        mensaje.setEmisor(emisor);
        final Usuario receptor = mensajeDTO.getReceptor() == null ? null : usuarioRepository.findById(mensajeDTO.getReceptor())
                .orElseThrow(() -> new NotFoundException("receptor not found"));
        mensaje.setReceptor(receptor);
        return mensaje;
    }

}
package edu.ecep.base_app.service;



@Service
@RequiredArgsConstructor
public class DetalleAsistenciaService {

    private final DetalleAsistenciaRepository repo;
    private final JornadaAsistenciaRepository jornadaRepo;
    private final DetalleAsistenciaMapper mapper;

    public List<DetalleAsistenciaDTO> findAll() {
        return repo.findAll().stream().map(mapper::toDto).toList();
    }

    @Transactional
    public Long marcar(DetalleAsistenciaCreateDTO dto) {
        // valida que la jornada exista
        JornadaAsistencia j = jornadaRepo.findById(dto.getJornadaId())
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Jornada no encontrada"));

        // bloquea si el trimestre de esa jornada está cerrado
        if (j.getTrimestre() != null && j.getTrimestre().isCerrado()) {
            throw new IllegalArgumentException("El trimestre está cerrado");
        }

        // evita duplicados (único por jornada + matrícula)
        if (repo.existsByJornadaIdAndMatriculaId(dto.getJornadaId(), dto.getMatriculaId())) {
            throw new IllegalArgumentException("Ya hay registro para esa matrícula en esa jornada");
        }

        return repo.save(mapper.toEntity(dto)).getId();
    }

    @Transactional
    public void delete(Long id) {
        if (!repo.existsById(id)) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Detalle no encontrado");
        }
        repo.deleteById(id);
    }

    @Transactional(readOnly = true)
    public List<DetalleAsistenciaDTO> search(Long jornadaId, Long matriculaId,
                                             LocalDate from, LocalDate to) {
        List<DetalleAsistencia> res;
        if (jornadaId != null) {
            res = repo.findByJornadaId(jornadaId);
        } else if (matriculaId != null && from != null && to != null) {
            res = repo.findByMatriculaIdAndJornada_FechaBetween(matriculaId, from, to);
        } else {
            res = repo.findAll();
        }
        return res.stream().map(mapper::toDto).toList();
    }
}
package edu.ecep.base_app.service;




@Service
public class FamiliarService {
    private final FamiliarRepository familiarRepository;

    private final AlumnoFamiliarRepository alumnoFamiliarRepository;
    private final AspiranteFamiliarRepository aspiranteFamiliarRepository;
    private final FamiliarMapper mapper;

    public FamiliarService(
            FamiliarRepository familiarRepository,
            AlumnoFamiliarRepository alumnoFamiliarRepository,
            AspiranteFamiliarRepository aspiranteFamiliarRepository,
            FamiliarMapper mapper
    ) {
        this.familiarRepository = familiarRepository;
        this.alumnoFamiliarRepository = alumnoFamiliarRepository;
        this.aspiranteFamiliarRepository = aspiranteFamiliarRepository;
        this.mapper = mapper;
    }

    public List<FamiliarDTO> findAll() {
        return familiarRepository.findAll(Sort.by("id")).stream().map(mapper::toDto).toList();
    }

    public FamiliarDTO get(Long id) {
        return familiarRepository.findById(id).map(mapper::toDto).orElseThrow(NotFoundException::new);
    }

    public Long create(FamiliarDTO dto) {
        return familiarRepository.save(mapper.toEntity(dto)).getId();
    }

    public void update(Long id, FamiliarDTO dto) {
        Familiar entity = familiarRepository.findById(id).orElseThrow(NotFoundException::new);
        mapper.update(entity, dto);
        familiarRepository.save(entity);
    }

    @Transactional
    public void delete(Long id) {
        ReferencedWarning warning = getReferencedWarning(id);
        if (warning != null) throw new ReferencedException(warning);
        if (!familiarRepository.existsById(id)) throw new NotFoundException("Familiar no encontrado: " + id);
        familiarRepository.deleteById(id);
    }

    public ReferencedWarning getReferencedWarning(Long id) {
        if (alumnoFamiliarRepository.existsByFamiliarId(id)) {
            ReferencedWarning w = new ReferencedWarning("familiar.referenciado.alumnoFamiliar");
            w.addParam(id);
            return w;
        }
        if (aspiranteFamiliarRepository.existsByFamiliarId(id)) {
            ReferencedWarning w = new ReferencedWarning("familiar.referenciado.aspiranteFamiliar");
            w.addParam(id);
            return w;
        }
        return null;
    }
}
package edu.ecep.base_app.service;





@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class AsistenciaQueryService {

    private final JornadaAsistenciaRepository jornadaRepo;
    private final DetalleAsistenciaRepository detalleRepo;
    private final AsignacionDocenteSeccionRepository asigSecRepo;
    private final SeccionMapper seccionMapper;

    public List<SeccionDTO> seccionesVigentesDocente(Long empleadoId, LocalDate fecha) {
        List<Seccion> secciones = asigSecRepo.findSeccionesVigentesByEmpleado(empleadoId, fecha);
        return secciones.stream().map(seccionMapper::toDto).toList();
    }

    public List<AsistenciaDiaDTO> historialSeccion(Long seccionId, LocalDate from, LocalDate to) {
        List<AsistenciaDiaDTO> lista = jornadaRepo.resumenDiario(seccionId, from, to);
        // completar porcentaje y ordenar
        lista.forEach(d -> d.setPorcentaje(pct(d.getPresentes(), d.getTotal())));
        return lista.stream()
                .sorted(Comparator.comparing(AsistenciaDiaDTO::getFecha).reversed())
                .toList();
    }

    public AsistenciaAcumuladoDTO acumuladoSeccion(Long seccionId, LocalDate from, LocalDate to) {
        AsistenciaAcumuladoDTO dto = detalleRepo.acumuladoSeccion(seccionId, from, to);
        if (dto == null) dto = new AsistenciaAcumuladoDTO();
        dto.setDesde(from);
        dto.setHasta(to);
        dto.setPorcentaje(pct(dto.getPresentes(), dto.getTotal()));
        return dto;
    }

    public List<AsistenciaAlumnoResumenDTO> resumenPorAlumno(Long seccionId, LocalDate from, LocalDate to) {
        List<AsistenciaAlumnoResumenDTO> lista = detalleRepo.resumenPorAlumno(seccionId, from, to);
        lista.forEach(d -> d.setPorcentaje(pct(d.getPresentes(), d.getTotal())));
        return lista;
    }

    private static double pct(int ok, int total) {
        if (total <= 0) return 0d;
        return Math.round((ok * 10000.0) / total) / 100.0;
    }
}
package edu.ecep.base_app.service;



@Service
@RequiredArgsConstructor
public class PeriodoEscolarService {
    private final PeriodoEscolarRepository repo; private final PeriodoEscolarMapper mapper;
    public List<PeriodoEscolarDTO> findAll(){ return repo.findAll(Sort.by("anio")).stream().map(mapper::toDto).toList(); }
    public PeriodoEscolarDTO get(Long id){ return repo.findById(id).map(mapper::toDto).orElseThrow(() -> new NotFoundException("No encontrado")); }
    public Long create(PeriodoEscolarCreateDTO dto){ if(repo.existsByAnio(dto.getAnio())) throw new IllegalArgumentException("Ya existe periodo para ese año"); return repo.save(mapper.toEntity(dto)).getId(); }
}



package edu.ecep.base_app.service;





@Service @RequiredArgsConstructor
public class MateriaService {
    private final MateriaRepository repo;
    private final MateriaMapper mapper;

    public List<MateriaDTO> findAll() {
        return repo.findAll(Sort.by("nombre")).stream().map(mapper::toDto).toList();
    }

    public Long create(MateriaCreateDTO dto) {
        if (repo.existsByNombreIgnoreCase(dto.getNombre())) {
            throw new IllegalArgumentException("Ya existe una materia con ese nombre");
        }
        return repo.save(mapper.toEntity(dto)).getId();
    }
}

package edu.ecep.base_app.service;



@Service
@RequiredArgsConstructor
public class MatriculaSeccionHistorialService {
    private final MatriculaSeccionHistorialRepository repo; private final MatriculaSeccionHistorialMapper mapper;
    public List<MatriculaSeccionHistorialDTO> findAll(){ return repo.findAll(Sort.by("matricula.id","desde").descending()).stream().map(mapper::toDto).toList(); }
    public Long asignar(MatriculaSeccionHistorialCreateDTO dto){
        if(dto.getHasta()!=null && dto.getHasta().isBefore(dto.getDesde())) throw new IllegalArgumentException("Rango inválido");
        // NOTA: acá podrías validar solapamientos con una consulta adicional
        return repo.save(mapper.toEntity(dto)).getId();
    }
}package edu.ecep.base_app.service;



@Service
public class UsuarioService {

    private final UsuarioRepository usuarioRepository;
    private final AlumnoRepository alumnoRepository;
    private final EmpleadoRepository empleadoRepository;
    private final FamiliarRepository familiarRepository;
    private final AspiranteRepository aspiranteRepository;

    public UsuarioService(
            UsuarioRepository usuarioRepository,
            AlumnoRepository alumnoRepository,
            EmpleadoRepository empleadoRepository,
            FamiliarRepository familiarRepository,
            AspiranteRepository aspiranteRepository
    ) {
        this.usuarioRepository = usuarioRepository;
        this.alumnoRepository = alumnoRepository;
        this.empleadoRepository = empleadoRepository;
        this.familiarRepository = familiarRepository;
        this.aspiranteRepository = aspiranteRepository;
    }

    public List<UsuarioDTO> findAll() {
        return usuarioRepository.findAll(Sort.by("id")).stream()
                .map(u -> mapToDTO(u, new UsuarioDTO()))
                .toList();
    }

    public UsuarioDTO get(final Long id) {
        return usuarioRepository.findById(id)
                .map(u -> mapToDTO(u, new UsuarioDTO()))
                .orElseThrow(NotFoundException::new);
    }

    public Long create(final UsuarioDTO dto) {
        Usuario u = new Usuario();
        mapToEntity(dto, u);
        return usuarioRepository.save(u).getId();
    }

    public void update(final Long id, final UsuarioDTO dto) {
        Usuario u = usuarioRepository.findById(id)
                .orElseThrow(NotFoundException::new);
        mapToEntity(dto, u);
        usuarioRepository.save(u);
    }

    @Transactional
    public void delete(Long id) {
        var usuario = usuarioRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Usuario no encontrado: " + id));

        var warn = getReferencedWarning(usuario);
        if (warn != null) throw new ReferencedException(warn);

        usuarioRepository.deleteById(id);
    }

    public ReferencedWarning getReferencedWarning(Usuario usuario) {
        Persona persona = usuario.getPersona();
        if (persona == null || persona.getId() == null) return null;

        Long personaId = persona.getId();

        if (alumnoRepository.existsByPersonaId(personaId)) {
            ReferencedWarning w = new ReferencedWarning("usuario.referenciado.alumno");
            w.addParam(usuario.getId());
            return w;
        }
        if (empleadoRepository.existsByPersonaId(personaId)) {
            ReferencedWarning w = new ReferencedWarning("usuario.referenciado.empleado");
            w.addParam(usuario.getId());
            return w;
        }
        if (familiarRepository.existsByPersonaId(personaId)) {
            ReferencedWarning w = new ReferencedWarning("usuario.referenciado.familiar");
            w.addParam(usuario.getId());
            return w;
        }
        if (aspiranteRepository.existsByPersonaId(personaId)) {
            ReferencedWarning w = new ReferencedWarning("usuario.referenciado.aspirante");
            w.addParam(usuario.getId());
            return w;
        }
        return null;
    }



    public Usuario findById(Long id) {
        return usuarioRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Usuario no encontrado"));
    }

    public Usuario getCurrent() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth == null) throw new ResponseStatusException(HttpStatus.UNAUTHORIZED);
        return (Usuario) auth.getDetails();
    }

    public UsuarioBusquedaDTO buscarUsuarioBusquedaPorId(Long id) {
        Usuario usuario = usuarioRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Usuario no encontrado"));

        return UsuarioBusquedaMapper.toDto(usuario);
    }



    public List<UsuarioBusquedaDTO> buscarUsuariosConTipo(String q, Long currentId) {
        String query = (q == null) ? "" : q.toLowerCase();

        return usuarioRepository.findAll().stream()
                .filter(u -> !u.getId().equals(currentId)) // excluye el usuario actual
                .filter(u -> {
                    if (query.isEmpty()) return true;
                    boolean matchEmail = u.getEmail() != null && u.getEmail().toLowerCase().contains(query);
                    boolean matchPersona = u.getPersona() != null && (
                            (u.getPersona().getNombre() != null && u.getPersona().getNombre().toLowerCase().contains(query)) ||
                                    (u.getPersona().getApellido() != null && u.getPersona().getApellido().toLowerCase().contains(query)) ||
                                    (u.getPersona().getDni() != null && u.getPersona().getDni().toLowerCase().contains(query))
                    );
                    return matchEmail || matchPersona;
                })
                .map(UsuarioBusquedaMapper::toDto)
                .toList();
    }


    /* ---------- mappers ---------- */
    private UsuarioDTO mapToDTO(Usuario u, UsuarioDTO dto) {
        dto.setId(u.getId());
        dto.setEmail(u.getEmail());
        dto.setPassword(u.getPassword());
        dto.setUserRoles(u.getUserRoles());
        return dto;
    }

    private void mapToEntity(UsuarioDTO dto, Usuario u) {
        u.setEmail(dto.getEmail());
        u.setPassword(dto.getPassword());
        u.setUserRoles(dto.getUserRoles());
    }

}package edu.ecep.base_app.service;


@Service
@RequiredArgsConstructor
public class LicenciaService {

    private final LicenciaRepository repository;
    private final LicenciaMapper mapper;

    public List<LicenciaDTO> findAll() {
        return repository.findAll(Sort.by("id"))
                .stream().map(mapper::toDto).toList();
    }

    public LicenciaDTO get(Long id) {
        return repository.findById(id)
                .map(mapper::toDto)
                .orElseThrow(NotFoundException::new);
    }

    // <- create con CreateDTO
    public Long create(LicenciaCreateDTO dto) {
        Licencia entity = mapper.toEntity(dto);
        return repository.save(entity).getId();
    }

    // <- update con DTO de lectura (o podrías tener un UpdateDTO si querés)
    public void update(Long id, LicenciaDTO dto) {
        Licencia entity = repository.findById(id)
                .orElseThrow(NotFoundException::new);
        mapper.update(entity, dto); // usa @MappingTarget en el mapper
        repository.save(entity);
    }

    public void delete(Long id) {
        repository.deleteById(id);
    }
}
package edu.ecep.base_app.service;


@Service
public class AlumnoFamiliarService {

    private final AlumnoFamiliarRepository repository;
    private final AlumnoFamiliarMapper mapper;

    public AlumnoFamiliarService(AlumnoFamiliarRepository repository, AlumnoFamiliarMapper mapper) {
        this.repository = repository;
        this.mapper = mapper;
    }

    public List<AlumnoFamiliarDTO> findAll() {
        return repository.findAll(Sort.by("id")).stream().map(mapper::toDto).toList();
    }

    public AlumnoFamiliarDTO get(Long id) {
        return repository.findById(id).map(mapper::toDto).orElseThrow(NotFoundException::new);
    }

    public Long create(AlumnoFamiliarCreateDTO dto) {
        if (repository.existsByAlumnoIdAndFamiliarId(dto.getAlumnoId(), dto.getFamiliarId())) {
            throw new IllegalArgumentException("El vínculo Alumno–Familiar ya existe.");
        }
        return repository.save(mapper.toEntity(dto)).getId();
    }

    public void update(Long id, AlumnoFamiliarDTO dto) {
        AlumnoFamiliar existing = repository.findById(id).orElseThrow(NotFoundException::new);
        // tambien se podria validar duplicados al cambiar ids:
        // if (dto.getAlumnoId()!=null && dto.getFamiliarId()!=null &&
        //     repository.existsByAlumnoIdAndFamiliarId(dto.getAlumnoId(), dto.getFamiliarId())) { ... }
        mapper.update(existing, dto);
        repository.save(existing);
    }

    public void delete(Long id) {
        repository.deleteById(id);
    }
}
package edu.ecep.base_app.service;



@Service
@RequiredArgsConstructor
public class AspiranteService {

    private final AspiranteRepository aspiranteRepository;
    private final PersonaRepository personaRepository;
    private final SolicitudAdmisionRepository solicitudAdmisionRepository;
    private final AspiranteFamiliarRepository aspiranteFamiliarRepository;
    private final AspiranteMapper mapper;

    public List<AspiranteDTO> findAll() {
        return aspiranteRepository.findAll(Sort.by("id"))
                .stream().map(mapper::toDto).toList();
    }

    public AspiranteDTO get(Long id) {
        return aspiranteRepository.findById(id)
                .map(mapper::toDto)
                .orElseThrow(() -> new NotFoundException("Aspirante no encontrado"));
    }

    @Transactional
    public AspiranteDTO create(AspiranteDTO dto) {
        // 1) Validar personaId
        Long personaId = dto.getPersonaId();
        if (personaId == null) {
            throw new IllegalArgumentException("personaId es obligatorio para crear un aspirante");
        }

        // 2) Buscar Persona
        Persona persona = personaRepository.findById(personaId)
                .orElseThrow(() -> new NotFoundException("Persona no encontrada"));

        // 3) Evitar duplicados (una misma persona no puede ser Aspirante dos veces)
        if (aspiranteRepository.existsByPersonaId(personaId)) {
            throw new IllegalArgumentException("La persona ya tiene rol Aspirante");
        }

        // 4) Crear Aspirante
        Aspirante a = new Aspirante();
        a.setPersona(persona);
        // copiar campos propios desde el dto (alta)
        copyPropsForCreate(a, dto);

        a = aspiranteRepository.save(a);
        return mapper.toDto(a);
    }

    @Transactional
    public AspiranteDTO update(Long id, AspiranteDTO dto) {
        Aspirante a = aspiranteRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Aspirante no encontrado"));

        // Con @MapsId NO permitimos cambiar la persona (cambia la PK).
        if (dto.getPersonaId() != null) {
            Long currentPersonaId = (a.getPersona() != null) ? a.getPersona().getId() : null;
            if (!dto.getPersonaId().equals(currentPersonaId)) {
                throw new IllegalArgumentException(
                        "No se puede cambiar la persona de un Aspirante. " +
                                "Elimine el registro y cree uno nuevo con el personaId correcto."
                );
            }
            // si es igual, seguimos (idempotente)
        }

        // patch de campos propios (solo no nulos)
        applyPatch(a, dto);
        // save no es necesario explícitamente (Hibernate flush con @Transactional),
        // pero lo dejamos si preferís retorno inmediato
        a = aspiranteRepository.save(a);

        return mapper.toDto(a);
    }

    @Transactional
    public void delete(Long id) {
        ReferencedWarning warning = getReferencedWarning(id);
        if (warning != null) throw new ReferencedException(warning);
        if (!aspiranteRepository.existsById(id)) {
            throw new NotFoundException("Aspirante no encontrado: " + id);
        }
        aspiranteRepository.deleteById(id);
    }

    public ReferencedWarning getReferencedWarning(Long id) {
        if (solicitudAdmisionRepository.existsByAspiranteId(id)) {
            ReferencedWarning w = new ReferencedWarning("aspirante.referenciado.solicitudes");
            w.addParam(id);
            return w;
        }
        if (aspiranteFamiliarRepository.existsByAspiranteId(id)) {
            ReferencedWarning w = new ReferencedWarning("aspirante.referenciado.familiares");
            w.addParam(id);
            return w;
        }
        return null;
    }

    /** Copia campos propios para el alta (puede aceptar nulls). */
    private void copyPropsForCreate(Aspirante a, AspiranteDTO dto) {
        a.setCursoSolicitado(dto.getCursoSolicitado());
        a.setTurnoPreferido(dto.getTurnoPreferido());
        a.setEscuelaActual(dto.getEscuelaActual());
        a.setConectividadInternet(dto.getConectividadInternet());
        a.setDispositivosDisponibles(dto.getDispositivosDisponibles());
        a.setIdiomasHabladosHogar(dto.getIdiomasHabladosHogar());
        a.setEnfermedadesAlergias(dto.getEnfermedadesAlergias());
        a.setMedicacionHabitual(dto.getMedicacionHabitual());
        a.setLimitacionesFisicas(dto.getLimitacionesFisicas());
        a.setTratamientosTerapeuticos(dto.getTratamientosTerapeuticos());
        a.setUsoAyudasMovilidad(dto.getUsoAyudasMovilidad());
        a.setCoberturaMedica(dto.getCoberturaMedica());
        a.setObservacionesSalud(dto.getObservacionesSalud());
    }

    /** Aplica patch: sólo pisa si el campo del dto NO es null. */
    private void applyPatch(Aspirante a, AspiranteDTO dto) {
        if (dto.getCursoSolicitado() != null)          a.setCursoSolicitado(dto.getCursoSolicitado());
        if (dto.getTurnoPreferido() != null)           a.setTurnoPreferido(dto.getTurnoPreferido());
        if (dto.getEscuelaActual() != null)            a.setEscuelaActual(dto.getEscuelaActual());
        if (dto.getConectividadInternet() != null)     a.setConectividadInternet(dto.getConectividadInternet());
        if (dto.getDispositivosDisponibles() != null)  a.setDispositivosDisponibles(dto.getDispositivosDisponibles());
        if (dto.getIdiomasHabladosHogar() != null)     a.setIdiomasHabladosHogar(dto.getIdiomasHabladosHogar());
        if (dto.getEnfermedadesAlergias() != null)     a.setEnfermedadesAlergias(dto.getEnfermedadesAlergias());
        if (dto.getMedicacionHabitual() != null)       a.setMedicacionHabitual(dto.getMedicacionHabitual());
        if (dto.getLimitacionesFisicas() != null)      a.setLimitacionesFisicas(dto.getLimitacionesFisicas());
        if (dto.getTratamientosTerapeuticos() != null) a.setTratamientosTerapeuticos(dto.getTratamientosTerapeuticos());
        if (dto.getUsoAyudasMovilidad() != null)       a.setUsoAyudasMovilidad(dto.getUsoAyudasMovilidad());
        if (dto.getCoberturaMedica() != null)          a.setCoberturaMedica(dto.getCoberturaMedica());
        if (dto.getObservacionesSalud() != null)       a.setObservacionesSalud(dto.getObservacionesSalud());
    }
}package edu.ecep.base_app.service;




@Service
@RequiredArgsConstructor
public class AsignacionDocenteMateriaService {
    private final AsignacionDocenteMateriaRepository repo; private final AsignacionDocenteMateriaMapper mapper;
    public List<AsignacionDocenteMateriaDTO> findAll(){ return repo.findAll().stream().map(mapper::toDto).toList(); }
    public Long create(AsignacionDocenteMateriaCreateDTO dto){
        LocalDate hasta = dto.getVigenciaHasta()==null? LocalDate.of(9999,12,31): dto.getVigenciaHasta();
        if(dto.getRol()== RolMateria.TITULAR && repo.hasTitularOverlap(dto.getSeccionMateriaId(), dto.getVigenciaDesde(), hasta, null))
            throw new IllegalArgumentException("Ya hay un titular vigente en ese rango");
        return repo.save(mapper.toEntity(dto)).getId();
    }
}
package edu.ecep.base_app.service;




@Service @RequiredArgsConstructor
public class PagoCuotaService {
    private final PagoCuotaRepository repo; private final PagoCuotaMapper mapper; private final CuotaRepository cuotaRepo;
    public List<PagoCuotaDTO> findAll(){ return repo.findAll(Sort.by("id")).stream().map(mapper::toDto).toList(); }
    public Long crearPago(PagoCuotaCreateDTO dto){
        // ejemplo de validación simple: código de pago existente
        Cuota c = cuotaRepo.findById(dto.getCuotaId()).orElseThrow(() -> new NotFoundException("No encontrado"));
        return repo.save(mapper.toEntity(dto)).getId();
    }
    @Transactional
    public void actualizarEstado(Long id, PagoCuotaEstadoUpdateDTO dto){
        PagoCuota p = repo.findById(id).orElseThrow(() -> new NotFoundException("No encontrado"));
        mapper.updateEstado(p, dto);
    }
}package edu.ecep.base_app.service;



@Service @RequiredArgsConstructor
public class ResultadoEvaluacionService {
    private final ResultadoEvaluacionRepository repo; private final ResultadoEvaluacionMapper mapper; private final EvaluacionRepository evalRepo; private final MatriculaSeccionHistorialRepository histRepo;
    public List<ResultadoEvaluacionDTO> findAll(){ return repo.findAll().stream().map(mapper::toDto).toList(); }
    public Long create(ResultadoEvaluacionCreateDTO dto){
        Evaluacion e = evalRepo.findById(dto.getEvaluacionId()).orElseThrow(() -> new NotFoundException("No encontrado"));
        // validación: matrícula debe estar en la sección de la evaluación en esa fecha
        List<MatriculaSeccionHistorial> h = histRepo.findVigente(dto.getMatriculaId(), e.getFecha());
        boolean ok = h.stream().anyMatch(x -> Objects.equals(x.getSeccion().getId(), e.getSeccionMateria().getSeccion().getId()));
        if(!ok) throw new IllegalArgumentException("La matrícula no estaba en la sección de la evaluación en esa fecha");
        if(repo.existsByEvaluacionIdAndMatriculaId(dto.getEvaluacionId(), dto.getMatriculaId())) throw new IllegalArgumentException("Resultado duplicado");
        return repo.save(mapper.toEntity(dto)).getId();
    }
}
package edu.ecep.base_app.service;







@Service
@RequiredArgsConstructor
@Transactional
public class TrimestreService {

    private final TrimestreRepository repo;
    private final TrimestreMapper mapper;

    @Transactional(readOnly = true)
    public List<TrimestreDTO> list() {
        return repo.findAll().stream().map(mapper::toDto).toList();
    }

    @Transactional(readOnly = true)
    public TrimestreDTO get(Long id) {
        Trimestre t = repo.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Trimestre " + id + " no encontrado"));
        return mapper.toDto(t);
    }

    public Long create(TrimestreCreateDTO dto) {
        Trimestre e = mapper.toEntity(dto);
        e.setCerrado(false);
        return repo.save(e).getId();
    }

    public void update(Long id, TrimestreDTO dto) {
        Trimestre t = repo.findById(id)
                .orElseThrow(() -> new NotFoundException("Trimestre no encontrado"));

        // Si necesitás tocar PeriodoEscolar relación, hacelo ANTES del merge
        // if (dto.getPeriodoEscolarId() != null) {
        //   t.setPeriodoEscolar(periodoRepo.getReferenceById(dto.getPeriodoEscolarId()));
        // }

        mapper.updateEntityFromDto(dto, t);
        repo.save(t);
    }

    public void cerrar(Long id) {
        Trimestre e = repo.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Trimestre " + id + " no encontrado"));
        e.setCerrado(true);
        repo.save(e);
    }

    public void reabrir(Long id) {
        Trimestre e = repo.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Trimestre " + id + " no encontrado"));
        e.setCerrado(false);
        repo.save(e);
    }
}
package edu.ecep.base_app.service;



@Service @RequiredArgsConstructor
public class CalificacionTrimestralService {
    private final CalificacionTrimestralRepository repo; private final CalificacionTrimestralMapper mapper; private final TrimestreRepository trimRepo;
    public List<CalificacionTrimestralDTO> findAll(){ return repo.findAll().stream().map(mapper::toDto).toList(); }
    public Long create(CalificacionTrimestralCreateDTO dto){
        Trimestre tri = trimRepo.findById(dto.getTrimestreId()).orElseThrow(() -> new NotFoundException("No encontrado"));
        if(tri.isCerrado()) throw new IllegalArgumentException("Trimestre cerrado");
        if(repo.existsByTrimestreIdAndSeccionMateriaIdAndMatriculaId(dto.getTrimestreId(), dto.getSeccionMateriaId(), dto.getMatriculaId()))
            throw new IllegalArgumentException("Calificación trimestral duplicada");
        return repo.save(mapper.toEntity(dto)).getId();
    }
}package edu.ecep.base_app.service;



@Service
@RequiredArgsConstructor
public class EmisionCuotaService {
    private final EmisionCuotaRepository repo; private final EmisionCuotaMapper mapper;
    public List<EmisionCuotaDTO> findAll(){ return repo.findAll(Sort.by("fechaEmision").descending()).stream().map(mapper::toDto).toList(); }
    public Long create(EmisionCuotaCreateDTO dto){ return repo.save(mapper.toEntity(dto)).getId(); }
}

@Servicepublic class AspiranteFamiliarService {    private final AspiranteFamiliarRepository repository;    private final AspiranteFamiliarMapper mapper;    public AspiranteFamiliarService(AspiranteFamiliarRepository repository, AspiranteFamiliarMapper mapper) {        this.repository = repository;        this.mapper = mapper;    }    public List<AspiranteFamiliarDTO> findAll() {        return repository.findAll(Sort.by("id")).stream().map(mapper::toDto).toList();    }    public AspiranteFamiliarDTO get(Long id) {        return repository.findById(id).map(mapper::toDto).orElseThrow(NotFoundException::new);    }    public Long create(AspiranteFamiliarDTO dto) {        return repository.save(mapper.toEntity(dto)).getId();    }    public void update(Long id, AspiranteFamiliarDTO dto) {        AspiranteFamiliar entity = repository.findById(id).orElseThrow(NotFoundException::new);        mapper.updateEntityFromDto(dto, entity);        repository.save(entity);    }    public void delete(Long id) {        repository.deleteById(id);    }}@Servicepublic class JwtService {    @Value("${jwt.secret}")    private String secret;    @Value("${jwt.expiration}")    private Long expiration;    // Generar token    public String generateToken(Usuario usuario) {        Map<String, Object> claims = new HashMap<>();        claims.put("roles", usuario.getRoles());        claims.put("email", usuario.getEmail());        return Jwts.builder()                .setClaims(claims)                .setSubject(usuario.getEmail())                .setIssuedAt(new Date())                .setExpiration(new Date(System.currentTimeMillis() + expiration))                .signWith(SignatureAlgorithm.HS256, secret)                .compact();    }    public String extractUsername(String token) {        return extractClaim(token, Claims::getSubject);    }    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {        final Claims claims = extractAllClaims(token);        return claimsResolver.apply(claims);    }    private Claims extractAllClaims(String token) {        return Jwts.parser()                .setSigningKey(secret)                .parseClaimsJws(token)                .getBody();    }    public boolean isTokenExpired(String token) {        return extractExpiration(token).before(new Date());    }    public Date extractExpiration(String token) {        return extractClaim(token, Claims::getExpiration);    }    public boolean validateToken(String token) {        try {            return !isTokenExpired(token);        } catch (Exception e) {            return false;        }    }    public Optional<String> safeExtractUsername(String token) {        try {            return Optional.ofNullable(extractUsername(token));        } catch (Exception e) {            return Optional.empty();        }    }}@Servicepublic class ActaAccidenteService {    private final ActaAccidenteRepository actaAccidenteRepository;    private final ActaAccidenteMapper actaAccidenteMapper;    public ActaAccidenteService(ActaAccidenteRepository actaAccidenteRepository,                                ActaAccidenteMapper actaAccidenteMapper) {        this.actaAccidenteRepository = actaAccidenteRepository;        this.actaAccidenteMapper = actaAccidenteMapper;    }    public List<ActaAccidenteDTO> findAll() {        return actaAccidenteRepository.findAll(Sort.by("id")).stream()                .map(actaAccidenteMapper::toDto)                .toList();    }    public ActaAccidenteDTO get(Long id) {        return actaAccidenteRepository.findById(id)                .map(actaAccidenteMapper::toDto)                .orElseThrow(NotFoundException::new);    }    public Long create(ActaAccidenteDTO dto) {        ActaAccidente entity = actaAccidenteMapper.toEntity(dto);        return actaAccidenteRepository.save(entity).getId();    }    public void update(Long id, ActaAccidenteDTO dto) {        ActaAccidente existing = actaAccidenteRepository.findById(id)                .orElseThrow(NotFoundException::new);        actaAccidenteMapper.updateEntityFromDto(dto, existing);        actaAccidenteRepository.save(existing);    }    public void delete(Long id) {        actaAccidenteRepository.deleteById(id);    }}@Servicepublic class MatriculaService {    private final MatriculaRepository matriculaRepository;    private final MatriculaMapper matriculaMapper;    public MatriculaService(MatriculaRepository matriculaRepository,                            MatriculaMapper matriculaMapper) {        this.matriculaRepository = matriculaRepository;        this.matriculaMapper = matriculaMapper;    }    public List<MatriculaDTO> findAll() {        return matriculaRepository.findAll(Sort.by("id")).stream()                .map(matriculaMapper::toDto)                .toList();    }    public MatriculaDTO get(Long id) {        return matriculaRepository.findById(id)                .map(matriculaMapper::toDto)                .orElseThrow(NotFoundException::new);    }    public Long create(MatriculaDTO dto) {        Matricula entity = matriculaMapper.toEntity(dto);        return matriculaRepository.save(entity).getId();    }    public void update(Long id, MatriculaDTO dto) {        Matricula existing = matriculaRepository.findById(id)                .orElseThrow(NotFoundException::new);        matriculaMapper.updateEntityFromDto(dto, existing);        matriculaRepository.save(existing);    }    public void delete(Long id) {        matriculaRepository.deleteById(id);    }}@Servicepublic class AsistenciaPersonalService {    private final AsistenciaPersonalRepository asistenciaDiaRepository;    private final AsistenciaPersonalMapper asistenciaDiaMapper;    public AsistenciaPersonalService(AsistenciaPersonalRepository asistenciaDiaRepository,                                AsistenciaPersonalMapper asistenciaDiaMapper) {        this.asistenciaDiaRepository = asistenciaDiaRepository;        this.asistenciaDiaMapper = asistenciaDiaMapper;    }    public List<AsistenciaPersonalDTO> findAll() {        return asistenciaDiaRepository.findAll(Sort.by("id")).stream()                .map(asistenciaDiaMapper::toDto)                .toList();    }    public AsistenciaPersonalDTO get(Long id) {        return asistenciaDiaRepository.findById(id)                .map(asistenciaDiaMapper::toDto)                .orElseThrow(NotFoundException::new);    }    public Long create(AsistenciaPersonalDTO dto) {        AsistenciaPersonal entity = asistenciaDiaMapper.toEntity(dto);        return asistenciaDiaRepository.save(entity).getId();    }    public void update(Long id, AsistenciaPersonalDTO dto) {        AsistenciaPersonal existing = asistenciaDiaRepository.findById(id)                .orElseThrow(NotFoundException::new);        asistenciaDiaMapper.updateEntityFromDto(dto, existing);        asistenciaDiaRepository.save(existing);    }    public void delete(Long id) {        asistenciaDiaRepository.deleteById(id);    }}package edu.ecep.base_app.service;@Servicepublic class DiaNoHabilService {    private final DiaNoHabilRepository repository;    private final DiaNoHabilMapper mapper;    public DiaNoHabilService(DiaNoHabilRepository repository, DiaNoHabilMapper mapper) {        this.repository = repository;        this.mapper = mapper;    }    public List<DiaNoHabilDTO> findAll() {        return repository.findAll(Sort.by("id")).stream().map(mapper::toDto).toList();    }    public DiaNoHabilDTO get(Long id) {        return repository.findById(id).map(mapper::toDto).orElseThrow(NotFoundException::new);    }    public Long create(DiaNoHabilDTO dto) {        return repository.save(mapper.toEntity(dto)).getId();    }    public void update(Long id, DiaNoHabilDTO dto) {        DiaNoHabil entity = repository.findById(id).orElseThrow(NotFoundException::new);        mapper.updateEntityFromDto(dto, entity);        repository.save(entity);    }    public void delete(Long id) {        repository.deleteById(id);    }}@Servicepublic class ComunicadoService {    private final ComunicadoRepository comunicadoRepository;    private final SeccionRepository seccionRepository;    private final UsuarioRepository usuarioRepository;    public ComunicadoService(final ComunicadoRepository comunicadoRepository,            final SeccionRepository seccionRepository, final UsuarioRepository usuarioRepository) {        this.comunicadoRepository = comunicadoRepository;        this.seccionRepository = seccionRepository;        this.usuarioRepository = usuarioRepository;    }    public List<ComunicadoDTO> findAll() {        final List<Comunicado> comunicadoes = comunicadoRepository.findAll(Sort.by("id"));        return comunicadoes.stream()                .map(comunicado -> mapToDTO(comunicado, new ComunicadoDTO()))                .toList();    }    public ComunicadoDTO get(final Long id) {        return comunicadoRepository.findById(id)                .map(comunicado -> mapToDTO(comunicado, new ComunicadoDTO()))                .orElseThrow(NotFoundException::new);    }    public Long create(final ComunicadoDTO comunicadoDTO) {        final Comunicado comunicado = new Comunicado();        mapToEntity(comunicadoDTO, comunicado);        return comunicadoRepository.save(comunicado).getId();    }    public void update(final Long id, final ComunicadoDTO comunicadoDTO) {        final Comunicado comunicado = comunicadoRepository.findById(id)                .orElseThrow(NotFoundException::new);        mapToEntity(comunicadoDTO, comunicado);        comunicadoRepository.save(comunicado);    }    public void delete(final Long id) {        comunicadoRepository.deleteById(id);    }    private ComunicadoDTO mapToDTO(final Comunicado comunicado, final ComunicadoDTO comunicadoDTO) {        comunicadoDTO.setId(comunicado.getId());        comunicadoDTO.setTitulo(comunicado.getTitulo());        comunicadoDTO.setCuerpoMensaje(comunicado.getCuerpoMensaje());        comunicadoDTO.setTipoComunicacion(comunicado.getTipoComunicacion());        comunicadoDTO.setNivelDestino(comunicado.getNivelDestino());        comunicadoDTO.setSeccionDestino(comunicado.getSeccionDestino() == null ? null : comunicado.getSeccionDestino().getId());        comunicadoDTO.setPublicador(comunicado.getPublicador() == null ? null : comunicado.getPublicador().getId());        return comunicadoDTO;    }    private Comunicado mapToEntity(final ComunicadoDTO comunicadoDTO, final Comunicado comunicado) {        comunicado.setTitulo(comunicadoDTO.getTitulo());        comunicado.setCuerpoMensaje(comunicadoDTO.getCuerpoMensaje());        comunicado.setTipoComunicacion(comunicadoDTO.getTipoComunicacion());        comunicado.setNivelDestino(comunicadoDTO.getNivelDestino());        final Seccion seccionDestino = comunicadoDTO.getSeccionDestino() == null ? null : seccionRepository.findById(comunicadoDTO.getSeccionDestino())                .orElseThrow(() -> new NotFoundException("seccionDestino not found"));        comunicado.setSeccionDestino(seccionDestino);        final Usuario publicador = comunicadoDTO.getPublicador() == null ? null : usuarioRepository.findById(comunicadoDTO.getPublicador())                .orElseThrow(() -> new NotFoundException("publicador not found"));        comunicado.setPublicador(publicador);        return comunicado;    }}@Servicepublic class CuotaService {    private final CuotaRepository repository;    private final CuotaMapper mapper;    public CuotaService(CuotaRepository repository, CuotaMapper mapper) {        this.repository = repository;        this.mapper = mapper;    }    public List<CuotaDTO> findAll() {        return repository.findAll(Sort.by("id")).stream().map(mapper::toDto).toList();    }    public CuotaDTO get(Long id) {        return repository.findById(id).map(mapper::toDto).orElseThrow(NotFoundException::new);    }    public Long create(CuotaDTO dto) {        return repository.save(mapper.toEntity(dto)).getId();    }    public void update(Long id, CuotaDTO dto) {        Cuota entity = repository.findById(id).orElseThrow(NotFoundException::new);        mapper.updateEntityFromDto(dto, entity);        repository.save(entity);    }    public void delete(Long id) {        repository.deleteById(id);    }}@Service@RequiredArgsConstructor@Transactionalpublic class ChatService {    private final MensajeRepository mensajeRepository;    private final UsuarioRepository usuarioRepository;    private final RedisTemplate<String, Object> redisTemplate;    private static final String CHANNEL = "chat";    private static final String ONLINE_USERS_KEY = "chat:online_users";    private static final String USER_LAST_SEEN_KEY = "chat:last_seen:";    /**     * Guarda el mensaje en la BD y lo publica por Redis para su diseminaci√≥n.     */    public Mensaje saveAndSend(SendMessageRequest request, Usuario emisor) {        // Validaciones        if (request.getContenido() == null || request.getContenido().trim().isEmpty()) {            throw new IllegalArgumentException("El mensaje no puede estar vac√≠o");        }        if (request.getContenido().length() > 1000) {            throw new IllegalArgumentException("El mensaje es demasiado largo");        }        // Creaci√≥n de entidad        Mensaje mensaje = new Mensaje();        mensaje.setEmisor(emisor);        mensaje.setReceptor(usuarioRepository.findById(request.getReceptorId())                .orElseThrow(() -> new IllegalArgumentException("Usuario receptor no encontrado")));        mensaje.setContenido(request.getContenido().trim());        mensaje.setFechaEnvio(OffsetDateTime.now());        mensaje.setLeido(false);        // Persistir en BD        Mensaje saved = mensajeRepository.save(mensaje);        // Convertir a DTO y publicar en Redis        ChatMessageDTO dto = toDto(saved);        redisTemplate.convertAndSend(CHANNEL, dto);        return saved;    }    public List<ChatMessageDTO> getHistory(Long userId, Long otherUserId) {        return mensajeRepository                .findConversation(userId, otherUserId)                .stream()                .map(this::toDto)                .sorted(Comparator.comparing(ChatMessageDTO::getFechaEnvio))                .collect(Collectors.toList());    }    public void markRead(Long userId, Long otherUserId) {        mensajeRepository.markAsRead(userId, otherUserId);        redisTemplate.opsForValue().set(                "chat:last_read:" + userId + ":" + otherUserId,                System.currentTimeMillis()        );    }    public Map<Long, Long> getUnreadCounts(Long userId) {        return mensajeRepository.getUnreadCounts(userId)                .stream()                .collect(Collectors.toMap(                        row -> (Long) row[0],                        row -> (Long) row[1]                ));    }    public List<Usuario> getActiveChatUsers(Long userId) {        List<Long> activeUserIds = mensajeRepository.getActiveChatUserIds(userId);        return usuarioRepository.findAllById(activeUserIds);    }    public void setUserOnline(Long userId) {        redisTemplate.opsForSet().add(ONLINE_USERS_KEY, userId.toString());        redisTemplate.opsForValue().set(USER_LAST_SEEN_KEY + userId, System.currentTimeMillis());    }    public void setUserOffline(Long userId) {        redisTemplate.opsForSet().remove(ONLINE_USERS_KEY, userId.toString());        redisTemplate.opsForValue().set(USER_LAST_SEEN_KEY + userId, System.currentTimeMillis());    }    public Map<Long, Boolean> getOnlineStatus(List<Long> userIds) {        return userIds.stream()                .collect(Collectors.toMap(                        id -> id,                        id -> redisTemplate.opsForSet().isMember(ONLINE_USERS_KEY, id.toString())                ));    }    public List<Long> getUserContacts(Long userId) {        return mensajeRepository.getUserContacts(userId);    }    /** Convierte la entidad Mensaje a ChatMessageDTO */    public ChatMessageDTO toDto(Mensaje mensaje) {        ChatMessageDTO dto = new ChatMessageDTO();        dto.setId(mensaje.getId());        dto.setEmisorId(mensaje.getEmisor().getId());        dto.setReceptorId(mensaje.getReceptor().getId());        dto.setContenido(mensaje.getContenido());        dto.setFechaEnvio(mensaje.getFechaEnvio());        dto.setLeido(mensaje.getLeido());        return dto;    }}@Servicepublic class AlumnoService {    private final AlumnoRepository alumnoRepository;    private final MatriculaRepository matriculaRepository;    private final AlumnoFamiliarRepository alumnoFamiliarRepository;    private final AlumnoMapper alumnoMapper;    public AlumnoService(            AlumnoRepository alumnoRepository,            MatriculaRepository matriculaRepository,            AlumnoFamiliarRepository alumnoFamiliarRepository,            AlumnoMapper alumnoMapper    ) {        this.alumnoRepository = alumnoRepository;        this.matriculaRepository = matriculaRepository;        this.alumnoFamiliarRepository = alumnoFamiliarRepository;        this.alumnoMapper = alumnoMapper;    }    public List<AlumnoDTO> findAll() {        return alumnoRepository.findAll(Sort.by("id")).stream()                .map(alumnoMapper::toDto)                .toList();    }    public AlumnoDTO get(Long id) {        return alumnoRepository.findById(id)                .map(alumnoMapper::toDto)                .orElseThrow(NotFoundException::new);    }    public Long create(AlumnoDTO dto) {        Alumno entity = alumnoMapper.toEntity(dto);        return alumnoRepository.save(entity).getId();    }    public void update(Long id, AlumnoDTO dto) {        Alumno existing = alumnoRepository.findById(id)                .orElseThrow(NotFoundException::new);        alumnoMapper.updateEntityFromDto(dto, existing);        alumnoRepository.save(existing);    }    @Transactional    public void delete(Long id) {        ReferencedWarning warning = getReferencedWarning(id);        if (warning != null) throw new ReferencedException(warning);        if (!alumnoRepository.existsById(id)) throw new NotFoundException("Alumno no encontrado: " + id);        alumnoRepository.deleteById(id);    }    public ReferencedWarning getReferencedWarning(Long id) {        if (matriculaRepository.existsByAlumnoId(id)) {            ReferencedWarning w = new ReferencedWarning("alumno.referenciado.matriculas");            w.addParam(id);            return w;        }        if (alumnoFamiliarRepository.existsByAlumnoId(id)) {            ReferencedWarning w = new ReferencedWarning("alumno.referenciado.familiares");            w.addParam(id);            return w;        }        return null;    }}@Servicepublic class SolicitudAdmisionService {    private final SolicitudAdmisionRepository repository;    private final SolicitudAdmisionMapper mapper;    public SolicitudAdmisionService(SolicitudAdmisionRepository repository, SolicitudAdmisionMapper mapper) {        this.repository = repository;        this.mapper = mapper;    }    public List<SolicitudAdmisionDTO> findAll() {        return repository.findAll(Sort.by("id")).stream().map(mapper::toDto).toList();    }    public SolicitudAdmisionDTO get(Long id) {        return repository.findById(id).map(mapper::toDto).orElseThrow(NotFoundException::new);    }    public Long create(SolicitudAdmisionDTO dto) {        return repository.save(mapper.toEntity(dto)).getId();    }    public void update(Long id, SolicitudAdmisionDTO dto) {        SolicitudAdmision entity = repository.findById(id).orElseThrow(NotFoundException::new);        mapper.updateEntityFromDto(dto, entity);        repository.save(entity);    }    public void delete(Long id) {        repository.deleteById(id);    }}@Servicepublic class AsistenciaDiaService {    private final AsistenciaDiaRepository asistenciaDiaRepository;    private final AsistenciaDiaMapper asistenciaDiaMapper;    public AsistenciaDiaService(AsistenciaDiaRepository asistenciaDiaRepository,                         AsistenciaDiaMapper asistenciaDiaMapper) {        this.asistenciaDiaRepository = asistenciaDiaRepository;        this.asistenciaDiaMapper = asistenciaDiaMapper;    }    public List<AsistenciaDiaDTO> findAll() {        return asistenciaDiaRepository.findAll(Sort.by("id")).stream()                .map(asistenciaDiaMapper::toDto)                .toList();    }    public AsistenciaDiaDTO get(Long id) {        return asistenciaDiaRepository.findById(id)                .map(asistenciaDiaMapper::toDto)                .orElseThrow(NotFoundException::new);    }    public Long create(AsistenciaDiaDTO dto) {        AsistenciaDia entity = asistenciaDiaMapper.toEntity(dto);        return asistenciaDiaRepository.save(entity).getId();    }    public void update(Long id, AsistenciaDiaDTO dto) {        AsistenciaDia existing = asistenciaDiaRepository.findById(id)                .orElseThrow(NotFoundException::new);        asistenciaDiaMapper.updateEntityFromDto(dto, existing);        asistenciaDiaRepository.save(existing);    }    public void delete(Long id) {        asistenciaDiaRepository.deleteById(id);    }}@Servicepublic class FormacionAcademicaService {    private final FormacionAcademicaRepository repository;    private final FormacionAcademicaMapper mapper;    public FormacionAcademicaService(FormacionAcademicaRepository repository, FormacionAcademicaMapper mapper) {        this.repository = repository;        this.mapper = mapper;    }    public List<FormacionAcademicaDTO> findAll() {        return repository.findAll(Sort.by("id")).stream().map(mapper::toDto).toList();    }    public FormacionAcademicaDTO get(Long id) {        return repository.findById(id).map(mapper::toDto).orElseThrow(NotFoundException::new);    }    public Long create(FormacionAcademicaDTO dto) {        return repository.save(mapper.toEntity(dto)).getId();    }    public void update(Long id, FormacionAcademicaDTO dto) {        FormacionAcademica entity = repository.findById(id).orElseThrow(NotFoundException::new);        mapper.updateEntityFromDto(dto, entity);        repository.save(entity);    }    public void delete(Long id) {        repository.deleteById(id);    }}@Servicepublic class EvaluacionService {    private final EvaluacionRepository repository;    private final EvaluacionMapper mapper;    public EvaluacionService(EvaluacionRepository repository, EvaluacionMapper mapper) {        this.repository = repository;        this.mapper = mapper;    }    public List<EvaluacionDTO> findAll() {        return repository.findAll(Sort.by("id")).stream().map(mapper::toDto).toList();    }    public EvaluacionDTO get(Long id) {        return repository.findById(id).map(mapper::toDto).orElseThrow(NotFoundException::new);    }    public Long create(EvaluacionDTO dto) {        return repository.save(mapper.toEntity(dto)).getId();    }    public void update(Long id, EvaluacionDTO dto) {        Evaluacion entity = repository.findById(id).orElseThrow(NotFoundException::new);        mapper.updateEntityFromDto(dto, entity);        repository.save(entity);    }    public void delete(Long id) {        repository.deleteById(id);    }}@Servicepublic class SeccionService {    private final SeccionRepository seccionRepository;    private final MatriculaRepository matriculaRepository;    private final EvaluacionRepository evaluacionRepository;    private final AsignacionDocenteRepository asignacionDocenteRepository;    private final AsistenciaDiaRepository asistenciaDiaRepository;    private final CuotaRepository cuotaRepository;    private final SeccionMapper mapper;    public SeccionService(            SeccionRepository seccionRepository,            MatriculaRepository matriculaRepository,            EvaluacionRepository evaluacionRepository,            AsignacionDocenteRepository asignacionDocenteRepository,            AsistenciaDiaRepository asistenciaDiaRepository,            CuotaRepository cuotaRepository,            SeccionMapper mapper    ) {        this.seccionRepository = seccionRepository;        this.matriculaRepository = matriculaRepository;        this.evaluacionRepository = evaluacionRepository;        this.asignacionDocenteRepository = asignacionDocenteRepository;        this.asistenciaDiaRepository = asistenciaDiaRepository;        this.cuotaRepository = cuotaRepository;        this.mapper = mapper;    }    public List<SeccionDTO> findAll() {        return seccionRepository.findAll(Sort.by("id")).stream().map(mapper::toDto).toList();    }    public SeccionDTO get(Long id) {        return seccionRepository.findById(id).map(mapper::toDto).orElseThrow(NotFoundException::new);    }    public Long create(SeccionDTO dto) {        return seccionRepository.save(mapper.toEntity(dto)).getId();    }    public void update(Long id, SeccionDTO dto) {        Seccion entity = seccionRepository.findById(id).orElseThrow(NotFoundException::new);        mapper.updateEntityFromDto(dto, entity);        seccionRepository.save(entity);    }    @Transactional    public void delete(Long id) {        ReferencedWarning warning = getReferencedWarning(id);        if (warning != null) throw new ReferencedException(warning);        if (!seccionRepository.existsById(id)) throw new NotFoundException("Secci√≥n no encontrada: " + id);        seccionRepository.deleteById(id);    }    public ReferencedWarning getReferencedWarning(Long id) {        if (matriculaRepository.existsBySeccionId(id)) {            ReferencedWarning w = new ReferencedWarning("seccion.referenciada.matriculas");            w.addParam(id);            return w;        }        if (evaluacionRepository.existsBySeccionId(id)) {            ReferencedWarning w = new ReferencedWarning("seccion.referenciada.evaluaciones");            w.addParam(id);            return w;        }        if (asignacionDocenteRepository.existsBySeccionId(id)) {            ReferencedWarning w = new ReferencedWarning("seccion.referenciada.asignaciones");            w.addParam(id);            return w;        }        if (asistenciaDiaRepository.existsBySeccionId(id)) {            ReferencedWarning w = new ReferencedWarning("seccion.referenciada.asistencias");            w.addParam(id);            return w;        }        if (cuotaRepository.existsBySeccionId(id)) {            ReferencedWarning w = new ReferencedWarning("seccion.referenciada.cuotas");            w.addParam(id);            return w;        }        return null;    }}@Componentpublic class RedisSubscriber {    private final SimpMessagingTemplate messagingTemplate;    private final ObjectMapper objectMapper;    public RedisSubscriber(SimpMessagingTemplate messagingTemplate,                           ObjectMapper objectMapper) {        this.messagingTemplate = messagingTemplate;        this.objectMapper = objectMapper;    }    public void handleMessage(String messageJson) throws Exception {        // üìå A√±ade un log aqu√≠ para verificar que se invoque        System.out.println("üîî RedisSubscriber got: " + messageJson);        ChatMessageDTO msg = objectMapper.readValue(messageJson, ChatMessageDTO.class);        System.out.println("üîî RedisSubscriber got: " + messageJson);        System.out.println("üõ∞Ô∏è Enviando a WS /user/" + msg.getReceptorId() + "/queue/messages");        messagingTemplate.convertAndSendToUser(                msg.getReceptorId().toString(),                "/queue/messages",                msg        );        System.out.println("‚úîÔ∏è Enviado al broker STOMP");    }}@Servicepublic class PersonalService {    private final PersonalRepository repository;    private final AsignacionDocenteRepository asignacionDocenteRepository;    private final PersonalRepository personalRepository;    private final ReciboSueldoRepository reciboSueldoRepository;    private final LicenciaRepository licenciaRepository;    private final AsistenciaPersonalRepository asistenciaPersonalRepository;    private final PersonalMapper mapper;    public PersonalService(            PersonalRepository repository,            AsignacionDocenteRepository asignacionDocenteRepository,            PersonalRepository personalRepository,            ReciboSueldoRepository reciboSueldoRepository,            LicenciaRepository licenciaRepository,            AsistenciaPersonalRepository asistenciaPersonalRepository,            PersonalMapper mapper    ) {        this.repository = repository;        this.asignacionDocenteRepository = asignacionDocenteRepository;        this.personalRepository = personalRepository;        this.reciboSueldoRepository = reciboSueldoRepository;        this.licenciaRepository = licenciaRepository;        this.asistenciaPersonalRepository = asistenciaPersonalRepository;        this.mapper = mapper;    }    public List<PersonalDTO> findAll() {        return repository.findAll(Sort.by("id")).stream().map(mapper::toDto).toList();    }    public PersonalDTO get(Long id) {        return repository.findById(id).map(mapper::toDto).orElseThrow(NotFoundException::new);    }    public Long create(PersonalDTO dto) {        return repository.save(mapper.toEntity(dto)).getId();    }    public void update(Long id, PersonalDTO dto) {        Personal entity = repository.findById(id).orElseThrow(NotFoundException::new);        mapper.updateEntityFromDto(dto, entity);        repository.save(entity);    }    @Transactional    public void delete(Long id) {        ReferencedWarning warning = getReferencedWarning(id);        if (warning != null) throw new ReferencedException(warning);        if (!personalRepository.existsById(id)) throw new NotFoundException("Personal no encontrado: " + id);        personalRepository.deleteById(id);    }    public ReferencedWarning getReferencedWarning(Long id) {        if (asignacionDocenteRepository.existsByDocenteId(id)) {            ReferencedWarning w = new ReferencedWarning("personal.referenciado.asignaciones");            w.addParam(id);            return w;        }        if (licenciaRepository.existsByPersonalId(id)) {            ReferencedWarning w = new ReferencedWarning("personal.referenciado.licencias");            w.addParam(id);            return w;        }        if (reciboSueldoRepository.existsByPersonalId(id)) {            ReferencedWarning w = new ReferencedWarning("personal.referenciado.recibosSueldo");            w.addParam(id);            return w;        }        if (asistenciaPersonalRepository.existsByPersonalId(id)) {            ReferencedWarning w = new ReferencedWarning("personal.referenciado.asistencias");            w.addParam(id);            return w;        }        return null;    }}@Servicepublic class InformeInicialService {    private final InformeInicialRepository repository;    private final InformeInicialMapper mapper;    public InformeInicialService(InformeInicialRepository repository, InformeInicialMapper mapper) {        this.repository = repository;        this.mapper = mapper;    }    public List<InformeInicialDTO> findAll() {        return repository.findAll(Sort.by("id")).stream().map(mapper::toDto).toList();    }    public InformeInicialDTO get(Long id) {        return repository.findById(id).map(mapper::toDto).orElseThrow(NotFoundException::new);    }    public Long create(InformeInicialDTO dto) {        return repository.save(mapper.toEntity(dto)).getId();    }    public void update(Long id, InformeInicialDTO dto) {        InformeInicial entity = repository.findById(id).orElseThrow(NotFoundException::new);        mapper.updateEntityFromDto(dto, entity);        repository.save(entity);    }    public void delete(Long id) {        repository.deleteById(id);    }}@Servicepublic class RedisPublisher {    private final RedisTemplate<String, Object> redisTemplate;    public RedisPublisher(RedisTemplate<String, Object> redisTemplate) {        this.redisTemplate = redisTemplate;    }    public void publish(String channel, Object message) {        redisTemplate.convertAndSend(channel, message);    }}@Servicepublic class ReciboSueldoService {    private final ReciboSueldoRepository repository;    private final ReciboSueldoMapper mapper;    public ReciboSueldoService(ReciboSueldoRepository repository, ReciboSueldoMapper mapper) {        this.repository = repository;        this.mapper = mapper;    }    public List<ReciboSueldoDTO> findAll() {        return repository.findAll(Sort.by("id")).stream().map(mapper::toDto).toList();    }    public ReciboSueldoDTO get(Long id) {        return repository.findById(id).map(mapper::toDto).orElseThrow(NotFoundException::new);    }    public Long create(ReciboSueldoDTO dto) {        return repository.save(mapper.toEntity(dto)).getId();    }    public void update(Long id, ReciboSueldoDTO dto) {        ReciboSueldo entity = repository.findById(id).orElseThrow(NotFoundException::new);        mapper.updateEntityFromDto(dto, entity);        repository.save(entity);    }    public void delete(Long id) {        repository.deleteById(id);    }}@Servicepublic class AuthService {    @Autowired    private UsuarioRepository usuarioRepository;    @Autowired    private PasswordEncoder passwordEncoder;    @Autowired    private JwtService jwtService;    @Autowired    private AuthenticationManager authenticationManager;    // LOGIN    public AuthResponse login(String email, String password) {        Usuario usuario = usuarioRepository.findByEmail(email)                .orElseThrow(() -> new UsernameNotFoundException("Usuario no encontrado"));        if (!passwordEncoder.matches(password, usuario.getPassword())) {            throw new BadCredentialsException("Credenciales inv√°lidas");        }        String token = jwtService.generateToken(usuario);        return new AuthResponse(token, usuario.getEmail(), usuario.getRoles());    }    // REGISTER    public AuthResponse register(Usuario request) {        if (usuarioRepository.existsByEmail(request.getEmail())) {            throw new RuntimeException("El email ya est√° registrado");        }        Usuario usuario = new Usuario();        usuario.setEmail(request.getEmail());        usuario.setPassword(passwordEncoder.encode(request.getPassword()));        usuario.setRoles(Set.of(Role.USER)); // Rol por defecto        usuario = usuarioRepository.save(usuario);        String token = jwtService.generateToken(usuario);        return new AuthResponse(token, usuario.getEmail(), usuario.getRoles());    }    // NUEVO M√âTODO: Obtener usuario actual como DTO    public Optional<UsuarioBusquedaDTO> getCurrentUserDTO(String email) {        return usuarioRepository.findByEmail(email)                .map(usuario -> {                    Persona p = usuario.getPersona();                    return new UsuarioBusquedaDTO(                            usuario.getId(),                            usuario.getEmail(),                            usuario.getRoles(),                            p != null ? p.getId() : null,                            p != null ? p.getNombre() + " " + p.getApellido() : null,                            p != null ? p.getDni() : null,                            p != null ? p.getClass().getSimpleName() : null                    );                });    }}@Servicepublic class MensajeService {    private final MensajeRepository mensajeRepository;    private final UsuarioRepository usuarioRepository;    public MensajeService(final MensajeRepository mensajeRepository,            final UsuarioRepository usuarioRepository) {        this.mensajeRepository = mensajeRepository;        this.usuarioRepository = usuarioRepository;    }    public List<MensajeDTO> findAll() {        final List<Mensaje> mensajes = mensajeRepository.findAll(Sort.by("id"));        return mensajes.stream()                .map(mensaje -> mapToDTO(mensaje, new MensajeDTO()))                .toList();    }    public MensajeDTO get(final Long id) {        return mensajeRepository.findById(id)                .map(mensaje -> mapToDTO(mensaje, new MensajeDTO()))                .orElseThrow(NotFoundException::new);    }    public Long create(final MensajeDTO mensajeDTO) {        final Mensaje mensaje = new Mensaje();        mapToEntity(mensajeDTO, mensaje);        return mensajeRepository.save(mensaje).getId();    }    public void update(final Long id, final MensajeDTO mensajeDTO) {        final Mensaje mensaje = mensajeRepository.findById(id)                .orElseThrow(NotFoundException::new);        mapToEntity(mensajeDTO, mensaje);        mensajeRepository.save(mensaje);    }    public void delete(final Long id) {        mensajeRepository.deleteById(id);    }    private MensajeDTO mapToDTO(final Mensaje mensaje, final MensajeDTO mensajeDTO) {        mensajeDTO.setId(mensaje.getId());        mensajeDTO.setFechaEnvio(mensaje.getFechaEnvio());        mensajeDTO.setAsunto(mensaje.getAsunto());        mensajeDTO.setContenido(mensaje.getContenido());        mensajeDTO.setLeido(mensaje.getLeido());        mensajeDTO.setEmisor(mensaje.getEmisor() == null ? null : mensaje.getEmisor().getId());        mensajeDTO.setReceptor(mensaje.getReceptor() == null ? null : mensaje.getReceptor().getId());        return mensajeDTO;    }    private Mensaje mapToEntity(final MensajeDTO mensajeDTO, final Mensaje mensaje) {        mensaje.setFechaEnvio(mensajeDTO.getFechaEnvio());        mensaje.setAsunto(mensajeDTO.getAsunto());        mensaje.setContenido(mensajeDTO.getContenido());        mensaje.setLeido(mensajeDTO.getLeido());        final Usuario emisor = mensajeDTO.getEmisor() == null ? null : usuarioRepository.findById(mensajeDTO.getEmisor())                .orElseThrow(() -> new NotFoundException("emisor not found"));        mensaje.setEmisor(emisor);        final Usuario receptor = mensajeDTO.getReceptor() == null ? null : usuarioRepository.findById(mensajeDTO.getReceptor())                .orElseThrow(() -> new NotFoundException("receptor not found"));        mensaje.setReceptor(receptor);        return mensaje;    }}@Servicepublic class RegistroAsistenciaService {    private final RegistroAsistenciaRepository repository;    private final RegistroAsistenciaMapper mapper;    public RegistroAsistenciaService(RegistroAsistenciaRepository repository, RegistroAsistenciaMapper mapper) {        this.repository = repository;        this.mapper = mapper;    }    public List<RegistroAsistenciaDTO> findAll() {        return repository.findAll(Sort.by("id")).stream().map(mapper::toDto).toList();    }    public RegistroAsistenciaDTO get(Long id) {        return repository.findById(id).map(mapper::toDto).orElseThrow(NotFoundException::new);    }    public Long create(RegistroAsistenciaDTO dto) {        return repository.save(mapper.toEntity(dto)).getId();    }    public void update(Long id, RegistroAsistenciaDTO dto) {        RegistroAsistencia entity = repository.findById(id).orElseThrow(NotFoundException::new);        mapper.updateEntityFromDto(dto, entity);        repository.save(entity);    }    public void delete(Long id) {        repository.deleteById(id);    }}@Servicepublic class FamiliarService {    private final FamiliarRepository familiarRepository;    private final AlumnoFamiliarRepository alumnoFamiliarRepository;    private final AspiranteFamiliarRepository aspiranteFamiliarRepository;    private final FamiliarMapper mapper;    public FamiliarService(            FamiliarRepository familiarRepository,            AlumnoFamiliarRepository alumnoFamiliarRepository,            AspiranteFamiliarRepository aspiranteFamiliarRepository,            FamiliarMapper mapper    ) {        this.familiarRepository = familiarRepository;        this.alumnoFamiliarRepository = alumnoFamiliarRepository;        this.aspiranteFamiliarRepository = aspiranteFamiliarRepository;        this.mapper = mapper;    }    public List<FamiliarDTO> findAll() {        return familiarRepository.findAll(Sort.by("id")).stream().map(mapper::toDto).toList();    }    public FamiliarDTO get(Long id) {        return familiarRepository.findById(id).map(mapper::toDto).orElseThrow(NotFoundException::new);    }    public Long create(FamiliarDTO dto) {        return familiarRepository.save(mapper.toEntity(dto)).getId();    }    public void update(Long id, FamiliarDTO dto) {        Familiar entity = familiarRepository.findById(id).orElseThrow(NotFoundException::new);        mapper.updateEntityFromDto(dto, entity);        familiarRepository.save(entity);    }    @Transactional    public void delete(Long id) {        ReferencedWarning warning = getReferencedWarning(id);        if (warning != null) throw new ReferencedException(warning);        if (!familiarRepository.existsById(id)) throw new NotFoundException("Familiar no encontrado: " + id);        familiarRepository.deleteById(id);    }    public ReferencedWarning getReferencedWarning(Long id) {        if (alumnoFamiliarRepository.existsByFamiliarId(id)) {            ReferencedWarning w = new ReferencedWarning("familiar.referenciado.alumnoFamiliar");            w.addParam(id);            return w;        }        if (aspiranteFamiliarRepository.existsByFamiliarId(id)) {            ReferencedWarning w = new ReferencedWarning("familiar.referenciado.aspiranteFamiliar");            w.addParam(id);            return w;        }        return null;    }}@Servicepublic class CalificacionService {    private final CalificacionRepository alumnoRepository;    private final CalificacionMapper alumnoMapper;    public CalificacionService(CalificacionRepository alumnoRepository,                         CalificacionMapper alumnoMapper) {        this.alumnoRepository = alumnoRepository;        this.alumnoMapper = alumnoMapper;    }    public List<CalificacionDTO> findAll() {        return alumnoRepository.findAll(Sort.by("id")).stream()                .map(alumnoMapper::toDto)                .toList();    }    public CalificacionDTO get(Long id) {        return alumnoRepository.findById(id)                .map(alumnoMapper::toDto)                .orElseThrow(NotFoundException::new);    }    public Long create(CalificacionDTO dto) {        Calificacion entity = alumnoMapper.toEntity(dto);        return alumnoRepository.save(entity).getId();    }    public void update(Long id, CalificacionDTO dto) {        Calificacion existing = alumnoRepository.findById(id)                .orElseThrow(NotFoundException::new);        alumnoMapper.updateEntityFromDto(dto, existing);        alumnoRepository.save(existing);    }    public void delete(Long id) {        alumnoRepository.deleteById(id);    }}@Servicepublic class MateriaService {    private final MateriaRepository materiaRepository;    private final EvaluacionRepository evaluacionRepository;    private final AsignacionDocenteRepository asignacionDocenteRepository;    private final MateriaMapper mapper;    public MateriaService(            MateriaRepository materiaRepository,            EvaluacionRepository evaluacionRepository,            AsignacionDocenteRepository asignacionDocenteRepository,            MateriaMapper mapper    ) {        this.materiaRepository = materiaRepository;        this.evaluacionRepository = evaluacionRepository;        this.asignacionDocenteRepository = asignacionDocenteRepository;        this.mapper = mapper;    }    public List<MateriaDTO> findAll() {        return materiaRepository.findAll(Sort.by("id")).stream().map(mapper::toDto).toList();    }    public MateriaDTO get(Long id) {        return materiaRepository.findById(id).map(mapper::toDto).orElseThrow(NotFoundException::new);    }    public Long create(MateriaDTO dto) {        return materiaRepository.save(mapper.toEntity(dto)).getId();    }    public void update(Long id, MateriaDTO dto) {        Materia entity = materiaRepository.findById(id).orElseThrow(NotFoundException::new);        mapper.updateEntityFromDto(dto, entity);        materiaRepository.save(entity);    }    @Transactional    public void delete(Long id) {        ReferencedWarning warning = getReferencedWarning(id);        if (warning != null) throw new ReferencedException(warning);        if (!materiaRepository.existsById(id)) throw new NotFoundException("Materia no encontrada: " + id);        materiaRepository.deleteById(id);    }    public ReferencedWarning getReferencedWarning(Long id) {        if (evaluacionRepository.existsByMateriaId(id)) {            ReferencedWarning w = new ReferencedWarning("materia.referenciada.evaluaciones");            w.addParam(id);            return w;        }        if (asignacionDocenteRepository.existsByMateriaId(id)) {            ReferencedWarning w = new ReferencedWarning("materia.referenciada.asignaciones");            w.addParam(id);            return w;        }        return null;    }}@Servicepublic class UsuarioService {    private final UsuarioRepository usuarioRepository;    private final AlumnoRepository alumnoRepository;    private final PersonalRepository personalRepository;    private final FamiliarRepository familiarRepository;    private final AspiranteRepository aspiranteRepository;    public UsuarioService(            UsuarioRepository usuarioRepository,            AlumnoRepository alumnoRepository,            PersonalRepository personalRepository,            FamiliarRepository familiarRepository,            AspiranteRepository aspiranteRepository    ) {        this.usuarioRepository = usuarioRepository;        this.alumnoRepository = alumnoRepository;        this.personalRepository = personalRepository;        this.familiarRepository = familiarRepository;        this.aspiranteRepository = aspiranteRepository;    }    public List<UsuarioDTO> findAll() {        return usuarioRepository.findAll(Sort.by("id")).stream()                .map(u -> mapToDTO(u, new UsuarioDTO()))                .toList();    }    public UsuarioDTO get(final Long id) {        return usuarioRepository.findById(id)                .map(u -> mapToDTO(u, new UsuarioDTO()))                .orElseThrow(NotFoundException::new);    }    public Long create(final UsuarioDTO dto) {        Usuario u = new Usuario();        mapToEntity(dto, u);        return usuarioRepository.save(u).getId();    }    public void update(final Long id, final UsuarioDTO dto) {        Usuario u = usuarioRepository.findById(id)                .orElseThrow(NotFoundException::new);        mapToEntity(dto, u);        usuarioRepository.save(u);    }    @Transactional    public void delete(Long id) {        ReferencedWarning warning = getReferencedWarning(id);        if (warning != null) throw new ReferencedException(warning);        if (!usuarioRepository.existsById(id)) throw new NotFoundException("Usuario no encontrado: " + id);        usuarioRepository.deleteById(id);    }    public ReferencedWarning getReferencedWarning(Long id) {        if (alumnoRepository.existsByUsuarioId(id)) {            ReferencedWarning w = new ReferencedWarning("usuario.referenciado.alumno");            w.addParam(id);            return w;        }        if (personalRepository.existsByUsuarioId(id)) {            ReferencedWarning w = new ReferencedWarning("usuario.referenciado.personal");            w.addParam(id);            return w;        }        if (familiarRepository.existsByUsuarioId(id)) {            ReferencedWarning w = new ReferencedWarning("usuario.referenciado.familiar");            w.addParam(id);            return w;        }        if (aspiranteRepository.existsByUsuarioId(id)) {            ReferencedWarning w = new ReferencedWarning("usuario.referenciado.aspirante");            w.addParam(id);            return w;        }        return null;    }    public Usuario findById(Long id) {        return usuarioRepository.findById(id)                .orElseThrow(() -> new EntityNotFoundException("Usuario no encontrado"));    }    public Usuario findByEmail(String email) {        return usuarioRepository.findByEmail(email)                .orElseThrow(() -> new UsernameNotFoundException("Usuario no encontrado: " + email));    }    public Usuario getCurrent() {        Authentication auth = SecurityContextHolder.getContext().getAuthentication();        if (auth == null) throw new ResponseStatusException(HttpStatus.UNAUTHORIZED);        return (Usuario) auth.getDetails();    }    public UsuarioBusquedaDTO buscarUsuarioBusquedaPorId(Long id) {        Usuario usuario = usuarioRepository.findById(id)                .orElseThrow(() -> new EntityNotFoundException("Usuario no encontrado"));        return UsuarioBusquedaMapper.toDto(usuario);    }    public List<UsuarioBusquedaDTO> buscarUsuariosConTipo(String q, Long currentId) {        String query = (q == null) ? "" : q.toLowerCase();        return usuarioRepository.findAll().stream()                .filter(u -> !u.getId().equals(currentId)) // excluye el usuario actual                .filter(u -> {                    if (query.isEmpty()) return true;                    boolean matchEmail = u.getEmail() != null && u.getEmail().toLowerCase().contains(query);                    boolean matchPersona = u.getPersona() != null && (                            (u.getPersona().getNombre() != null && u.getPersona().getNombre().toLowerCase().contains(query)) ||                                    (u.getPersona().getApellido() != null && u.getPersona().getApellido().toLowerCase().contains(query)) ||                                    (u.getPersona().getDni() != null && u.getPersona().getDni().toLowerCase().contains(query))                    );                    return matchEmail || matchPersona;                })                .map(UsuarioBusquedaMapper::toDto)                .toList();    }    /* ---------- mappers ---------- */    private UsuarioDTO mapToDTO(Usuario u, UsuarioDTO dto) {        dto.setId(u.getId());        dto.setEmail(u.getEmail());        dto.setPassword(u.getPassword());        dto.setRoles(u.getRoles());        return dto;    }    private void mapToEntity(UsuarioDTO dto, Usuario u) {        u.setEmail(dto.getEmail());        u.setPassword(dto.getPassword());        u.setRoles(dto.getRoles());    }}package edu.ecep.base_app.service;@Servicepublic class LicenciaService {    private final LicenciaRepository repository;    private final LicenciaMapper mapper;    public LicenciaService(LicenciaRepository repository, LicenciaMapper mapper) {        this.repository = repository;        this.mapper = mapper;    }    public List<LicenciaDTO> findAll() {        return repository.findAll(Sort.by("id")).stream().map(mapper::toDto).toList();    }    public LicenciaDTO get(Long id) {        return repository.findById(id).map(mapper::toDto).orElseThrow(NotFoundException::new);    }    public Long create(LicenciaDTO dto) {        return repository.save(mapper.toEntity(dto)).getId();    }    public void update(Long id, LicenciaDTO dto) {        Licencia entity = repository.findById(id).orElseThrow(NotFoundException::new);        mapper.updateEntityFromDto(dto, entity);        repository.save(entity);    }    public void delete(Long id) {        repository.deleteById(id);    }}@Servicepublic class AlumnoFamiliarService {    private final AlumnoFamiliarRepository repository;    private final AlumnoFamiliarMapper mapper;    public AlumnoFamiliarService(AlumnoFamiliarRepository repository,                                 AlumnoFamiliarMapper mapper) {        this.repository = repository;        this.mapper = mapper;    }    public List<AlumnoFamiliarDTO> findAll() {        return repository.findAll(Sort.by("id")).stream()                .map(mapper::toDto)                .toList();    }    public AlumnoFamiliarDTO get(Long id) {        return repository.findById(id)                .map(mapper::toDto)                .orElseThrow(NotFoundException::new);    }    public Long create(AlumnoFamiliarDTO dto) {        return repository.save(mapper.toEntity(dto)).getId();    }    public void update(Long id, AlumnoFamiliarDTO dto) {        AlumnoFamiliar existing = repository.findById(id)                .orElseThrow(NotFoundException::new);        mapper.updateEntityFromDto(dto, existing);        repository.save(existing);    }    public void delete(Long id) {        repository.deleteById(id);    }}@Servicepublic class AspiranteService {    private final AspiranteRepository aspiranteRepository;    private final SolicitudAdmisionRepository solicitudAdmisionRepository;    private final AspiranteFamiliarRepository aspiranteFamiliarRepository;    private final AspiranteMapper mapper;    public AspiranteService(            AspiranteRepository aspiranteRepository,            SolicitudAdmisionRepository solicitudAdmisionRepository,            AspiranteFamiliarRepository aspiranteFamiliarRepository,            AspiranteMapper mapper    ) {        this.aspiranteRepository = aspiranteRepository;        this.solicitudAdmisionRepository = solicitudAdmisionRepository;        this.aspiranteFamiliarRepository = aspiranteFamiliarRepository;        this.mapper = mapper;    }    public List<AspiranteDTO> findAll() {        return aspiranteRepository.findAll(Sort.by("id")).stream().map(mapper::toDto).toList();    }    public AspiranteDTO get(Long id) {        return aspiranteRepository.findById(id).map(mapper::toDto).orElseThrow(NotFoundException::new);    }    public Long create(AspiranteDTO dto) {        return aspiranteRepository.save(mapper.toEntity(dto)).getId();    }    public Aspirante crear(AspiranteDTO dto) {        if (aspiranteRepository.existsByDni(dto.getDni())) {            throw new DuplicateDniException("El DNI %s ya est√° registrado".formatted(dto.getDni()));        }        Aspirante ent = mapper.toEntity(dto);        return aspiranteRepository.save(ent);    }    public void update(Long id, AspiranteDTO dto) {        Aspirante entity = aspiranteRepository.findById(id).orElseThrow(NotFoundException::new);        mapper.updateEntityFromDto(dto, entity);        aspiranteRepository.save(entity);    }    @Transactional    public void delete(Long id) {        ReferencedWarning warning = getReferencedWarning(id);        if (warning != null) throw new ReferencedException(warning);        if (!aspiranteRepository.existsById(id)) throw new NotFoundException("Aspirante no encontrado: " + id);        aspiranteRepository.deleteById(id);    }    public ReferencedWarning getReferencedWarning(Long id) {        if (solicitudAdmisionRepository.existsByAspiranteId(id)) {            ReferencedWarning w = new ReferencedWarning("aspirante.referenciado.solicitudes");            w.addParam(id);            return w;        }        if (aspiranteFamiliarRepository.existsByAspiranteId(id)) {            ReferencedWarning w = new ReferencedWarning("aspirante.referenciado.familiares");            w.addParam(id);            return w;        }        return null;    }}@Servicepublic class PagoCuotaService {    private final PagoCuotaRepository repository;    private final PagoCuotaMapper mapper;    public PagoCuotaService(PagoCuotaRepository repository, PagoCuotaMapper mapper) {        this.repository = repository;        this.mapper = mapper;    }    public List<PagoCuotaDTO> findAll() {        return repository.findAll(Sort.by("id")).stream().map(mapper::toDto).toList();    }    public PagoCuotaDTO get(Long id) {        return repository.findById(id).map(mapper::toDto).orElseThrow(NotFoundException::new);    }    public Long create(PagoCuotaDTO dto) {        return repository.save(mapper.toEntity(dto)).getId();    }    public void update(Long id, PagoCuotaDTO dto) {        PagoCuota entity = repository.findById(id).orElseThrow(NotFoundException::new);        mapper.updateEntityFromDto(dto, entity);        repository.save(entity);    }    public void delete(Long id) {        repository.deleteById(id);    }}@Servicepublic class AsignacionDocenteService {    private final AsignacionDocenteRepository actaAccidenteRepository;    private final AsignacionDocenteMapper actaAccidenteMapper;    public AsignacionDocenteService(AsignacionDocenteRepository actaAccidenteRepository,                                AsignacionDocenteMapper actaAccidenteMapper) {        this.actaAccidenteRepository = actaAccidenteRepository;        this.actaAccidenteMapper = actaAccidenteMapper;    }    public List<AsignacionDocenteDTO> findAll() {        return actaAccidenteRepository.findAll(Sort.by("id")).stream()                .map(actaAccidenteMapper::toDto)                .toList();    }    public AsignacionDocenteDTO get(Long id) {        return actaAccidenteRepository.findById(id)                .map(actaAccidenteMapper::toDto)                .orElseThrow(NotFoundException::new);    }    public Long create(AsignacionDocenteDTO dto) {        AsignacionDocente entity = actaAccidenteMapper.toEntity(dto);        return actaAccidenteRepository.save(entity).getId();    }    public void update(Long id, AsignacionDocenteDTO dto) {        AsignacionDocente existing = actaAccidenteRepository.findById(id)                .orElseThrow(NotFoundException::new);        actaAccidenteMapper.updateEntityFromDto(dto, existing);        actaAccidenteRepository.save(existing);    }    public void delete(Long id) {        actaAccidenteRepository.deleteById(id);    }}